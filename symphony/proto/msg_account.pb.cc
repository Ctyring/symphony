// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: symphony/proto/msg_account.proto

#include "symphony/proto/msg_account.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace symphony {
namespace proto {
PROTOBUF_CONSTEXPR CheckVersionReq::CheckVersionReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.clientverion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CheckVersionReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckVersionReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckVersionReqDefaultTypeInternal() {}
  union {
    CheckVersionReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckVersionReqDefaultTypeInternal _CheckVersionReq_default_instance_;
PROTOBUF_CONSTEXPR CheckVersionAck::CheckVersionAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.clientverion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.retcode_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CheckVersionAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckVersionAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckVersionAckDefaultTypeInternal() {}
  union {
    CheckVersionAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckVersionAckDefaultTypeInternal _CheckVersionAck_default_instance_;
PROTOBUF_CONSTEXPR AccountLog::AccountLog(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.idfa_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.imodel_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.imei_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_.ipaddr_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountLogDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountLogDefaultTypeInternal() {}
  union {
    AccountLog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountLogDefaultTypeInternal _AccountLog_default_instance_;
PROTOBUF_CONSTEXPR AccountRegReq::AccountRegReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reglog_)*/nullptr
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountRegReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountRegReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountRegReqDefaultTypeInternal() {}
  union {
    AccountRegReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountRegReqDefaultTypeInternal _AccountRegReq_default_instance_;
PROTOBUF_CONSTEXPR AccountRegAck::AccountRegAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_.retcode_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountRegAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountRegAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountRegAckDefaultTypeInternal() {}
  union {
    AccountRegAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountRegAckDefaultTypeInternal _AccountRegAck_default_instance_;
PROTOBUF_CONSTEXPR AccountLoginReq::AccountLoginReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.loginlog_)*/nullptr
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_.fromchannel_)*/false
  , /*decltype(_impl_.review_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountLoginReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountLoginReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountLoginReqDefaultTypeInternal() {}
  union {
    AccountLoginReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountLoginReqDefaultTypeInternal _AccountLoginReq_default_instance_;
PROTOBUF_CONSTEXPR AccountLoginAck::AccountLoginAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.lastsvrname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_.retcode_)*/0u
  , /*decltype(_impl_.lastsvrid_)*/0
  , /*decltype(_impl_.review_)*/false
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_.ipaddr_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountLoginAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountLoginAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountLoginAckDefaultTypeInternal() {}
  union {
    AccountLoginAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountLoginAckDefaultTypeInternal _AccountLoginAck_default_instance_;
PROTOBUF_CONSTEXPR ClientServerListReq::ClientServerListReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_.review_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ClientServerListReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientServerListReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientServerListReqDefaultTypeInternal() {}
  union {
    ClientServerListReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientServerListReqDefaultTypeInternal _ClientServerListReq_default_instance_;
PROTOBUF_CONSTEXPR ClientServerNode::ClientServerNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.svrname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.svrid_)*/0
  , /*decltype(_impl_.svrflag_)*/0
  , /*decltype(_impl_.svropentime_)*/int64_t{0}
  , /*decltype(_impl_.cornermark_)*/0
  , /*decltype(_impl_.svrstatus_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ClientServerNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientServerNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientServerNodeDefaultTypeInternal() {}
  union {
    ClientServerNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientServerNodeDefaultTypeInternal _ClientServerNode_default_instance_;
PROTOBUF_CONSTEXPR ClientServerListAck::ClientServerListAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.svrnode_)*/{}
  , /*decltype(_impl_.retcode_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ClientServerListAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientServerListAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientServerListAckDefaultTypeInternal() {}
  union {
    ClientServerListAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientServerListAckDefaultTypeInternal _ClientServerListAck_default_instance_;
PROTOBUF_CONSTEXPR SelectServerReq::SelectServerReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_.serverid_)*/0
  , /*decltype(_impl_.checkrole_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SelectServerReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectServerReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectServerReqDefaultTypeInternal() {}
  union {
    SelectServerReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectServerReqDefaultTypeInternal _SelectServerReq_default_instance_;
PROTOBUF_CONSTEXPR SelectServerAck::SelectServerAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.serveraddr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_.retcode_)*/0u
  , /*decltype(_impl_.serverid_)*/0
  , /*decltype(_impl_.serverport_)*/0
  , /*decltype(_impl_.logincode_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SelectServerAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectServerAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectServerAckDefaultTypeInternal() {}
  union {
    SelectServerAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectServerAckDefaultTypeInternal _SelectServerAck_default_instance_;
PROTOBUF_CONSTEXPR SealAccountReq::SealAccountReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_.sealtime_)*/0
  , /*decltype(_impl_.seal_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SealAccountReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SealAccountReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SealAccountReqDefaultTypeInternal() {}
  union {
    SealAccountReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SealAccountReqDefaultTypeInternal _SealAccountReq_default_instance_;
PROTOBUF_CONSTEXPR SealAccountAck::SealAccountAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.retcode_)*/0u
  , /*decltype(_impl_.serverid_)*/0
  , /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SealAccountAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SealAccountAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SealAccountAckDefaultTypeInternal() {}
  union {
    SealAccountAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SealAccountAckDefaultTypeInternal _SealAccountAck_default_instance_;
PROTOBUF_CONSTEXPR SealAccountNtf::SealAccountNtf(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SealAccountNtfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SealAccountNtfDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SealAccountNtfDefaultTypeInternal() {}
  union {
    SealAccountNtf _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SealAccountNtfDefaultTypeInternal _SealAccountNtf_default_instance_;
PROTOBUF_CONSTEXPR SetLastServerNty::SetLastServerNty(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_.serverid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetLastServerNtyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetLastServerNtyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetLastServerNtyDefaultTypeInternal() {}
  union {
    SetLastServerNty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetLastServerNtyDefaultTypeInternal _SetLastServerNty_default_instance_;
}  // namespace proto
}  // namespace symphony
static ::_pb::Metadata file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[16];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_symphony_2fproto_2fmsg_5faccount_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_symphony_2fproto_2fmsg_5faccount_2eproto = nullptr;

const uint32_t TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::CheckVersionReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::CheckVersionReq, _impl_.clientverion_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::CheckVersionReq, _impl_.channel_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::CheckVersionAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::CheckVersionAck, _impl_.retcode_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::CheckVersionAck, _impl_.clientverion_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLog, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLog, _impl_.channel_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLog, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLog, _impl_.accountid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLog, _impl_.uuid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLog, _impl_.idfa_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLog, _impl_.imodel_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLog, _impl_.imei_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLog, _impl_.ipaddr_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountRegReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountRegReq, _impl_.accountname_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountRegReq, _impl_.password_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountRegReq, _impl_.channel_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountRegReq, _impl_.reglog_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountRegAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountRegAck, _impl_.retcode_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountRegAck, _impl_.accountid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginReq, _impl_.accountname_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginReq, _impl_.password_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginReq, _impl_.channel_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginReq, _impl_.fromchannel_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginReq, _impl_.review_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginReq, _impl_.loginlog_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginAck, _impl_.retcode_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginAck, _impl_.accountid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginAck, _impl_.lastsvrid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginAck, _impl_.lastsvrname_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginAck, _impl_.review_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginAck, _impl_.channel_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::AccountLoginAck, _impl_.ipaddr_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerListReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerListReq, _impl_.accountid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerListReq, _impl_.channel_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerListReq, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerListReq, _impl_.review_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerNode, _impl_.svrid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerNode, _impl_.svrname_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerNode, _impl_.svrflag_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerNode, _impl_.cornermark_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerNode, _impl_.svropentime_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerNode, _impl_.svrstatus_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerListAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerListAck, _impl_.retcode_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::ClientServerListAck, _impl_.svrnode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SelectServerReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SelectServerReq, _impl_.accountid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SelectServerReq, _impl_.serverid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SelectServerReq, _impl_.checkrole_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SelectServerAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SelectServerAck, _impl_.retcode_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SelectServerAck, _impl_.accountid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SelectServerAck, _impl_.serverid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SelectServerAck, _impl_.serveraddr_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SelectServerAck, _impl_.serverport_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SelectServerAck, _impl_.logincode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountReq, _impl_.accountname_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountReq, _impl_.accountid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountReq, _impl_.channel_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountReq, _impl_.sealtime_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountReq, _impl_.seal_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountAck, _impl_.retcode_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountAck, _impl_.accountname_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountAck, _impl_.accountid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountAck, _impl_.serverid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountNtf, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SealAccountNtf, _impl_.accountid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SetLastServerNty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SetLastServerNty, _impl_.accountid_),
  PROTOBUF_FIELD_OFFSET(::symphony::proto::SetLastServerNty, _impl_.serverid_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::symphony::proto::CheckVersionReq)},
  { 8, -1, -1, sizeof(::symphony::proto::CheckVersionAck)},
  { 16, -1, -1, sizeof(::symphony::proto::AccountLog)},
  { 30, -1, -1, sizeof(::symphony::proto::AccountRegReq)},
  { 40, -1, -1, sizeof(::symphony::proto::AccountRegAck)},
  { 48, -1, -1, sizeof(::symphony::proto::AccountLoginReq)},
  { 60, -1, -1, sizeof(::symphony::proto::AccountLoginAck)},
  { 73, -1, -1, sizeof(::symphony::proto::ClientServerListReq)},
  { 83, -1, -1, sizeof(::symphony::proto::ClientServerNode)},
  { 95, -1, -1, sizeof(::symphony::proto::ClientServerListAck)},
  { 103, -1, -1, sizeof(::symphony::proto::SelectServerReq)},
  { 112, -1, -1, sizeof(::symphony::proto::SelectServerAck)},
  { 124, -1, -1, sizeof(::symphony::proto::SealAccountReq)},
  { 135, -1, -1, sizeof(::symphony::proto::SealAccountAck)},
  { 145, -1, -1, sizeof(::symphony::proto::SealAccountNtf)},
  { 152, -1, -1, sizeof(::symphony::proto::SetLastServerNty)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::symphony::proto::_CheckVersionReq_default_instance_._instance,
  &::symphony::proto::_CheckVersionAck_default_instance_._instance,
  &::symphony::proto::_AccountLog_default_instance_._instance,
  &::symphony::proto::_AccountRegReq_default_instance_._instance,
  &::symphony::proto::_AccountRegAck_default_instance_._instance,
  &::symphony::proto::_AccountLoginReq_default_instance_._instance,
  &::symphony::proto::_AccountLoginAck_default_instance_._instance,
  &::symphony::proto::_ClientServerListReq_default_instance_._instance,
  &::symphony::proto::_ClientServerNode_default_instance_._instance,
  &::symphony::proto::_ClientServerListAck_default_instance_._instance,
  &::symphony::proto::_SelectServerReq_default_instance_._instance,
  &::symphony::proto::_SelectServerAck_default_instance_._instance,
  &::symphony::proto::_SealAccountReq_default_instance_._instance,
  &::symphony::proto::_SealAccountAck_default_instance_._instance,
  &::symphony::proto::_SealAccountNtf_default_instance_._instance,
  &::symphony::proto::_SetLastServerNty_default_instance_._instance,
};

const char descriptor_table_protodef_symphony_2fproto_2fmsg_5faccount_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n symphony/proto/msg_account.proto\022\016symp"
  "hony.proto\"8\n\017CheckVersionReq\022\024\n\014ClientV"
  "erion\030\001 \001(\t\022\017\n\007Channel\030\002 \001(\005\"8\n\017CheckVer"
  "sionAck\022\017\n\007RetCode\030\001 \001(\r\022\024\n\014ClientVerion"
  "\030\002 \001(\t\"\213\001\n\nAccountLog\022\017\n\007Channel\030\001 \001(\005\022\017"
  "\n\007Version\030\002 \001(\t\022\021\n\tAccountID\030\003 \001(\004\022\014\n\004Uu"
  "id\030\004 \001(\t\022\014\n\004Idfa\030\005 \001(\t\022\016\n\006Imodel\030\006 \001(\t\022\014"
  "\n\004Imei\030\007 \001(\t\022\016\n\006IpAddr\030\010 \001(\005\"s\n\rAccountR"
  "egReq\022\023\n\013AccountName\030\001 \001(\t\022\020\n\010Password\030\002"
  " \001(\t\022\017\n\007Channel\030\003 \001(\005\022*\n\006RegLog\030\004 \001(\0132\032."
  "symphony.proto.AccountLog\"3\n\rAccountRegA"
  "ck\022\017\n\007RetCode\030\001 \001(\r\022\021\n\tAccountID\030\002 \001(\004\"\234"
  "\001\n\017AccountLoginReq\022\023\n\013AccountName\030\001 \001(\t\022"
  "\020\n\010Password\030\002 \001(\t\022\017\n\007Channel\030\003 \001(\005\022\023\n\013Fr"
  "omChannel\030\004 \001(\010\022\016\n\006Review\030\005 \001(\010\022,\n\010Login"
  "Log\030\006 \001(\0132\032.symphony.proto.AccountLog\"\216\001"
  "\n\017AccountLoginAck\022\017\n\007RetCode\030\001 \001(\r\022\021\n\tAc"
  "countID\030\002 \001(\004\022\021\n\tLastSvrID\030\003 \001(\005\022\023\n\013Last"
  "SvrName\030\004 \001(\t\022\016\n\006Review\030\005 \001(\010\022\017\n\007Channel"
  "\030\006 \001(\005\022\016\n\006IpAddr\030\007 \001(\005\"Z\n\023ClientServerLi"
  "stReq\022\021\n\tAccountID\030\001 \001(\004\022\017\n\007Channel\030\002 \001("
  "\005\022\017\n\007Version\030\003 \001(\t\022\016\n\006Review\030\004 \001(\010\"\177\n\020Cl"
  "ientServerNode\022\r\n\005SvrID\030\001 \001(\005\022\017\n\007SvrName"
  "\030\002 \001(\t\022\017\n\007SvrFlag\030\003 \001(\005\022\022\n\nCornerMark\030\004 "
  "\001(\005\022\023\n\013SvrOpenTime\030\005 \001(\003\022\021\n\tSvrStatus\030\006 "
  "\001(\005\"Y\n\023ClientServerListAck\022\017\n\007RetCode\030\001 "
  "\001(\r\0221\n\007SvrNode\030\002 \003(\0132 .symphony.proto.Cl"
  "ientServerNode\"I\n\017SelectServerReq\022\021\n\tAcc"
  "ountID\030\001 \001(\004\022\020\n\010ServerID\030\002 \001(\005\022\021\n\tCheckR"
  "ole\030\003 \001(\010\"\202\001\n\017SelectServerAck\022\017\n\007RetCode"
  "\030\001 \001(\r\022\021\n\tAccountID\030\002 \001(\004\022\020\n\010ServerID\030\003 "
  "\001(\005\022\022\n\nServerAddr\030\004 \001(\t\022\022\n\nServerPort\030\005 "
  "\001(\005\022\021\n\tLoginCode\030\006 \001(\005\"i\n\016SealAccountReq"
  "\022\023\n\013AccountName\030\001 \001(\t\022\021\n\tAccountID\030\002 \001(\004"
  "\022\017\n\007Channel\030\003 \001(\005\022\020\n\010SealTime\030\004 \001(\005\022\014\n\004S"
  "eal\030\005 \001(\010\"[\n\016SealAccountAck\022\017\n\007RetCode\030\001"
  " \001(\r\022\023\n\013AccountName\030\002 \001(\t\022\021\n\tAccountID\030\003"
  " \001(\004\022\020\n\010ServerID\030\004 \001(\005\"#\n\016SealAccountNtf"
  "\022\021\n\tAccountID\030\001 \001(\004\"7\n\020SetLastServerNty\022"
  "\021\n\tAccountID\030\001 \001(\004\022\020\n\010ServerID\030\002 \001(\005b\006pr"
  "oto3"
  ;
static ::_pbi::once_flag descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto = {
    false, false, 1604, descriptor_table_protodef_symphony_2fproto_2fmsg_5faccount_2eproto,
    "symphony/proto/msg_account.proto",
    &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once, nullptr, 0, 16,
    schemas, file_default_instances, TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto::offsets,
    file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto, file_level_enum_descriptors_symphony_2fproto_2fmsg_5faccount_2eproto,
    file_level_service_descriptors_symphony_2fproto_2fmsg_5faccount_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter() {
  return &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_symphony_2fproto_2fmsg_5faccount_2eproto(&descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto);
namespace symphony {
namespace proto {

// ===================================================================

class CheckVersionReq::_Internal {
 public:
};

CheckVersionReq::CheckVersionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.CheckVersionReq)
}
CheckVersionReq::CheckVersionReq(const CheckVersionReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CheckVersionReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.clientverion_){}
    , decltype(_impl_.channel_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.clientverion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.clientverion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_clientverion().empty()) {
    _this->_impl_.clientverion_.Set(from._internal_clientverion(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.channel_ = from._impl_.channel_;
  // @@protoc_insertion_point(copy_constructor:symphony.proto.CheckVersionReq)
}

inline void CheckVersionReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.clientverion_){}
    , decltype(_impl_.channel_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.clientverion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.clientverion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CheckVersionReq::~CheckVersionReq() {
  // @@protoc_insertion_point(destructor:symphony.proto.CheckVersionReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckVersionReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.clientverion_.Destroy();
}

void CheckVersionReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckVersionReq::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.CheckVersionReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.clientverion_.ClearToEmpty();
  _impl_.channel_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckVersionReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ClientVerion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_clientverion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.CheckVersionReq.ClientVerion"));
        } else
          goto handle_unusual;
        continue;
      // int32 Channel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckVersionReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.CheckVersionReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ClientVerion = 1;
  if (!this->_internal_clientverion().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_clientverion().data(), static_cast<int>(this->_internal_clientverion().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.CheckVersionReq.ClientVerion");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_clientverion(), target);
  }

  // int32 Channel = 2;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_channel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.CheckVersionReq)
  return target;
}

size_t CheckVersionReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.CheckVersionReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ClientVerion = 1;
  if (!this->_internal_clientverion().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_clientverion());
  }

  // int32 Channel = 2;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channel());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CheckVersionReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CheckVersionReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CheckVersionReq::GetClassData() const { return &_class_data_; }


void CheckVersionReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CheckVersionReq*>(&to_msg);
  auto& from = static_cast<const CheckVersionReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.CheckVersionReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_clientverion().empty()) {
    _this->_internal_set_clientverion(from._internal_clientverion());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CheckVersionReq::CopyFrom(const CheckVersionReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.CheckVersionReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckVersionReq::IsInitialized() const {
  return true;
}

void CheckVersionReq::InternalSwap(CheckVersionReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.clientverion_, lhs_arena,
      &other->_impl_.clientverion_, rhs_arena
  );
  swap(_impl_.channel_, other->_impl_.channel_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckVersionReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[0]);
}

// ===================================================================

class CheckVersionAck::_Internal {
 public:
};

CheckVersionAck::CheckVersionAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.CheckVersionAck)
}
CheckVersionAck::CheckVersionAck(const CheckVersionAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CheckVersionAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.clientverion_){}
    , decltype(_impl_.retcode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.clientverion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.clientverion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_clientverion().empty()) {
    _this->_impl_.clientverion_.Set(from._internal_clientverion(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.retcode_ = from._impl_.retcode_;
  // @@protoc_insertion_point(copy_constructor:symphony.proto.CheckVersionAck)
}

inline void CheckVersionAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.clientverion_){}
    , decltype(_impl_.retcode_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.clientverion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.clientverion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CheckVersionAck::~CheckVersionAck() {
  // @@protoc_insertion_point(destructor:symphony.proto.CheckVersionAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckVersionAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.clientverion_.Destroy();
}

void CheckVersionAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckVersionAck::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.CheckVersionAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.clientverion_.ClearToEmpty();
  _impl_.retcode_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckVersionAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 RetCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.retcode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string ClientVerion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_clientverion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.CheckVersionAck.ClientVerion"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckVersionAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.CheckVersionAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 RetCode = 1;
  if (this->_internal_retcode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_retcode(), target);
  }

  // string ClientVerion = 2;
  if (!this->_internal_clientverion().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_clientverion().data(), static_cast<int>(this->_internal_clientverion().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.CheckVersionAck.ClientVerion");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_clientverion(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.CheckVersionAck)
  return target;
}

size_t CheckVersionAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.CheckVersionAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ClientVerion = 2;
  if (!this->_internal_clientverion().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_clientverion());
  }

  // uint32 RetCode = 1;
  if (this->_internal_retcode() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_retcode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CheckVersionAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CheckVersionAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CheckVersionAck::GetClassData() const { return &_class_data_; }


void CheckVersionAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CheckVersionAck*>(&to_msg);
  auto& from = static_cast<const CheckVersionAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.CheckVersionAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_clientverion().empty()) {
    _this->_internal_set_clientverion(from._internal_clientverion());
  }
  if (from._internal_retcode() != 0) {
    _this->_internal_set_retcode(from._internal_retcode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CheckVersionAck::CopyFrom(const CheckVersionAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.CheckVersionAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckVersionAck::IsInitialized() const {
  return true;
}

void CheckVersionAck::InternalSwap(CheckVersionAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.clientverion_, lhs_arena,
      &other->_impl_.clientverion_, rhs_arena
  );
  swap(_impl_.retcode_, other->_impl_.retcode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckVersionAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[1]);
}

// ===================================================================

class AccountLog::_Internal {
 public:
};

AccountLog::AccountLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.AccountLog)
}
AccountLog::AccountLog(const AccountLog& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountLog* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.version_){}
    , decltype(_impl_.uuid_){}
    , decltype(_impl_.idfa_){}
    , decltype(_impl_.imodel_){}
    , decltype(_impl_.imei_){}
    , decltype(_impl_.accountid_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.ipaddr_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_uuid().empty()) {
    _this->_impl_.uuid_.Set(from._internal_uuid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.idfa_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.idfa_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_idfa().empty()) {
    _this->_impl_.idfa_.Set(from._internal_idfa(), 
      _this->GetArenaForAllocation());
  }
  _impl_.imodel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imodel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_imodel().empty()) {
    _this->_impl_.imodel_.Set(from._internal_imodel(), 
      _this->GetArenaForAllocation());
  }
  _impl_.imei_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imei_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_imei().empty()) {
    _this->_impl_.imei_.Set(from._internal_imei(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ipaddr_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.ipaddr_));
  // @@protoc_insertion_point(copy_constructor:symphony.proto.AccountLog)
}

inline void AccountLog::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.version_){}
    , decltype(_impl_.uuid_){}
    , decltype(_impl_.idfa_){}
    , decltype(_impl_.imodel_){}
    , decltype(_impl_.imei_){}
    , decltype(_impl_.accountid_){uint64_t{0u}}
    , decltype(_impl_.channel_){0}
    , decltype(_impl_.ipaddr_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.idfa_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.idfa_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.imodel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imodel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.imei_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imei_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountLog::~AccountLog() {
  // @@protoc_insertion_point(destructor:symphony.proto.AccountLog)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountLog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.version_.Destroy();
  _impl_.uuid_.Destroy();
  _impl_.idfa_.Destroy();
  _impl_.imodel_.Destroy();
  _impl_.imei_.Destroy();
}

void AccountLog::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountLog::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.AccountLog)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.version_.ClearToEmpty();
  _impl_.uuid_.ClearToEmpty();
  _impl_.idfa_.ClearToEmpty();
  _impl_.imodel_.ClearToEmpty();
  _impl_.imei_.ClearToEmpty();
  ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.ipaddr_) -
      reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.ipaddr_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountLog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Channel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.AccountLog.Version"));
        } else
          goto handle_unusual;
        continue;
      // uint64 AccountID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Uuid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.AccountLog.Uuid"));
        } else
          goto handle_unusual;
        continue;
      // string Idfa = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_idfa();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.AccountLog.Idfa"));
        } else
          goto handle_unusual;
        continue;
      // string Imodel = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_imodel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.AccountLog.Imodel"));
        } else
          goto handle_unusual;
        continue;
      // string Imei = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_imei();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.AccountLog.Imei"));
        } else
          goto handle_unusual;
        continue;
      // int32 IpAddr = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.ipaddr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountLog::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.AccountLog)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Channel = 1;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_channel(), target);
  }

  // string Version = 2;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.AccountLog.Version");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_version(), target);
  }

  // uint64 AccountID = 3;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_accountid(), target);
  }

  // string Uuid = 4;
  if (!this->_internal_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_uuid().data(), static_cast<int>(this->_internal_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.AccountLog.Uuid");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_uuid(), target);
  }

  // string Idfa = 5;
  if (!this->_internal_idfa().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_idfa().data(), static_cast<int>(this->_internal_idfa().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.AccountLog.Idfa");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_idfa(), target);
  }

  // string Imodel = 6;
  if (!this->_internal_imodel().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_imodel().data(), static_cast<int>(this->_internal_imodel().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.AccountLog.Imodel");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_imodel(), target);
  }

  // string Imei = 7;
  if (!this->_internal_imei().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_imei().data(), static_cast<int>(this->_internal_imei().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.AccountLog.Imei");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_imei(), target);
  }

  // int32 IpAddr = 8;
  if (this->_internal_ipaddr() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_ipaddr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.AccountLog)
  return target;
}

size_t AccountLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.AccountLog)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Version = 2;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // string Uuid = 4;
  if (!this->_internal_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uuid());
  }

  // string Idfa = 5;
  if (!this->_internal_idfa().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_idfa());
  }

  // string Imodel = 6;
  if (!this->_internal_imodel().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_imodel());
  }

  // string Imei = 7;
  if (!this->_internal_imei().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_imei());
  }

  // uint64 AccountID = 3;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  // int32 Channel = 1;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channel());
  }

  // int32 IpAddr = 8;
  if (this->_internal_ipaddr() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ipaddr());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountLog::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountLog::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountLog::GetClassData() const { return &_class_data_; }


void AccountLog::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountLog*>(&to_msg);
  auto& from = static_cast<const AccountLog&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.AccountLog)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (!from._internal_uuid().empty()) {
    _this->_internal_set_uuid(from._internal_uuid());
  }
  if (!from._internal_idfa().empty()) {
    _this->_internal_set_idfa(from._internal_idfa());
  }
  if (!from._internal_imodel().empty()) {
    _this->_internal_set_imodel(from._internal_imodel());
  }
  if (!from._internal_imei().empty()) {
    _this->_internal_set_imei(from._internal_imei());
  }
  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  if (from._internal_ipaddr() != 0) {
    _this->_internal_set_ipaddr(from._internal_ipaddr());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountLog::CopyFrom(const AccountLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.AccountLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountLog::IsInitialized() const {
  return true;
}

void AccountLog::InternalSwap(AccountLog* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uuid_, lhs_arena,
      &other->_impl_.uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.idfa_, lhs_arena,
      &other->_impl_.idfa_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.imodel_, lhs_arena,
      &other->_impl_.imodel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.imei_, lhs_arena,
      &other->_impl_.imei_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountLog, _impl_.ipaddr_)
      + sizeof(AccountLog::_impl_.ipaddr_)
      - PROTOBUF_FIELD_OFFSET(AccountLog, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountLog::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[2]);
}

// ===================================================================

class AccountRegReq::_Internal {
 public:
  static const ::symphony::proto::AccountLog& reglog(const AccountRegReq* msg);
};

const ::symphony::proto::AccountLog&
AccountRegReq::_Internal::reglog(const AccountRegReq* msg) {
  return *msg->_impl_.reglog_;
}
AccountRegReq::AccountRegReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.AccountRegReq)
}
AccountRegReq::AccountRegReq(const AccountRegReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountRegReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountname_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.reglog_){nullptr}
    , decltype(_impl_.channel_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.accountname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accountname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_accountname().empty()) {
    _this->_impl_.accountname_.Set(from._internal_accountname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_reglog()) {
    _this->_impl_.reglog_ = new ::symphony::proto::AccountLog(*from._impl_.reglog_);
  }
  _this->_impl_.channel_ = from._impl_.channel_;
  // @@protoc_insertion_point(copy_constructor:symphony.proto.AccountRegReq)
}

inline void AccountRegReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountname_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.reglog_){nullptr}
    , decltype(_impl_.channel_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.accountname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accountname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountRegReq::~AccountRegReq() {
  // @@protoc_insertion_point(destructor:symphony.proto.AccountRegReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountRegReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.accountname_.Destroy();
  _impl_.password_.Destroy();
  if (this != internal_default_instance()) delete _impl_.reglog_;
}

void AccountRegReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountRegReq::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.AccountRegReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accountname_.ClearToEmpty();
  _impl_.password_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.reglog_ != nullptr) {
    delete _impl_.reglog_;
  }
  _impl_.reglog_ = nullptr;
  _impl_.channel_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountRegReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string AccountName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_accountname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.AccountRegReq.AccountName"));
        } else
          goto handle_unusual;
        continue;
      // string Password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.AccountRegReq.Password"));
        } else
          goto handle_unusual;
        continue;
      // int32 Channel = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .symphony.proto.AccountLog RegLog = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_reglog(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountRegReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.AccountRegReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string AccountName = 1;
  if (!this->_internal_accountname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_accountname().data(), static_cast<int>(this->_internal_accountname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.AccountRegReq.AccountName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_accountname(), target);
  }

  // string Password = 2;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.AccountRegReq.Password");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  // int32 Channel = 3;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_channel(), target);
  }

  // .symphony.proto.AccountLog RegLog = 4;
  if (this->_internal_has_reglog()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::reglog(this),
        _Internal::reglog(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.AccountRegReq)
  return target;
}

size_t AccountRegReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.AccountRegReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string AccountName = 1;
  if (!this->_internal_accountname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_accountname());
  }

  // string Password = 2;
  if (!this->_internal_password().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  // .symphony.proto.AccountLog RegLog = 4;
  if (this->_internal_has_reglog()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.reglog_);
  }

  // int32 Channel = 3;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channel());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountRegReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountRegReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountRegReq::GetClassData() const { return &_class_data_; }


void AccountRegReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountRegReq*>(&to_msg);
  auto& from = static_cast<const AccountRegReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.AccountRegReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_accountname().empty()) {
    _this->_internal_set_accountname(from._internal_accountname());
  }
  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  if (from._internal_has_reglog()) {
    _this->_internal_mutable_reglog()->::symphony::proto::AccountLog::MergeFrom(
        from._internal_reglog());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountRegReq::CopyFrom(const AccountRegReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.AccountRegReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountRegReq::IsInitialized() const {
  return true;
}

void AccountRegReq::InternalSwap(AccountRegReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.accountname_, lhs_arena,
      &other->_impl_.accountname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountRegReq, _impl_.channel_)
      + sizeof(AccountRegReq::_impl_.channel_)
      - PROTOBUF_FIELD_OFFSET(AccountRegReq, _impl_.reglog_)>(
          reinterpret_cast<char*>(&_impl_.reglog_),
          reinterpret_cast<char*>(&other->_impl_.reglog_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountRegReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[3]);
}

// ===================================================================

class AccountRegAck::_Internal {
 public:
};

AccountRegAck::AccountRegAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.AccountRegAck)
}
AccountRegAck::AccountRegAck(const AccountRegAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountRegAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){}
    , decltype(_impl_.retcode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.retcode_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.retcode_));
  // @@protoc_insertion_point(copy_constructor:symphony.proto.AccountRegAck)
}

inline void AccountRegAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){uint64_t{0u}}
    , decltype(_impl_.retcode_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AccountRegAck::~AccountRegAck() {
  // @@protoc_insertion_point(destructor:symphony.proto.AccountRegAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountRegAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AccountRegAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountRegAck::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.AccountRegAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.retcode_) -
      reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.retcode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountRegAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 RetCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.retcode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 AccountID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountRegAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.AccountRegAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 RetCode = 1;
  if (this->_internal_retcode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_retcode(), target);
  }

  // uint64 AccountID = 2;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_accountid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.AccountRegAck)
  return target;
}

size_t AccountRegAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.AccountRegAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 AccountID = 2;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  // uint32 RetCode = 1;
  if (this->_internal_retcode() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_retcode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountRegAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountRegAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountRegAck::GetClassData() const { return &_class_data_; }


void AccountRegAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountRegAck*>(&to_msg);
  auto& from = static_cast<const AccountRegAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.AccountRegAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  if (from._internal_retcode() != 0) {
    _this->_internal_set_retcode(from._internal_retcode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountRegAck::CopyFrom(const AccountRegAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.AccountRegAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountRegAck::IsInitialized() const {
  return true;
}

void AccountRegAck::InternalSwap(AccountRegAck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountRegAck, _impl_.retcode_)
      + sizeof(AccountRegAck::_impl_.retcode_)
      - PROTOBUF_FIELD_OFFSET(AccountRegAck, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountRegAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[4]);
}

// ===================================================================

class AccountLoginReq::_Internal {
 public:
  static const ::symphony::proto::AccountLog& loginlog(const AccountLoginReq* msg);
};

const ::symphony::proto::AccountLog&
AccountLoginReq::_Internal::loginlog(const AccountLoginReq* msg) {
  return *msg->_impl_.loginlog_;
}
AccountLoginReq::AccountLoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.AccountLoginReq)
}
AccountLoginReq::AccountLoginReq(const AccountLoginReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountLoginReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountname_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.loginlog_){nullptr}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.fromchannel_){}
    , decltype(_impl_.review_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.accountname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accountname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_accountname().empty()) {
    _this->_impl_.accountname_.Set(from._internal_accountname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_loginlog()) {
    _this->_impl_.loginlog_ = new ::symphony::proto::AccountLog(*from._impl_.loginlog_);
  }
  ::memcpy(&_impl_.channel_, &from._impl_.channel_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.review_) -
    reinterpret_cast<char*>(&_impl_.channel_)) + sizeof(_impl_.review_));
  // @@protoc_insertion_point(copy_constructor:symphony.proto.AccountLoginReq)
}

inline void AccountLoginReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountname_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.loginlog_){nullptr}
    , decltype(_impl_.channel_){0}
    , decltype(_impl_.fromchannel_){false}
    , decltype(_impl_.review_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.accountname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accountname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountLoginReq::~AccountLoginReq() {
  // @@protoc_insertion_point(destructor:symphony.proto.AccountLoginReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountLoginReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.accountname_.Destroy();
  _impl_.password_.Destroy();
  if (this != internal_default_instance()) delete _impl_.loginlog_;
}

void AccountLoginReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountLoginReq::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.AccountLoginReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accountname_.ClearToEmpty();
  _impl_.password_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.loginlog_ != nullptr) {
    delete _impl_.loginlog_;
  }
  _impl_.loginlog_ = nullptr;
  ::memset(&_impl_.channel_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.review_) -
      reinterpret_cast<char*>(&_impl_.channel_)) + sizeof(_impl_.review_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountLoginReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string AccountName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_accountname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.AccountLoginReq.AccountName"));
        } else
          goto handle_unusual;
        continue;
      // string Password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.AccountLoginReq.Password"));
        } else
          goto handle_unusual;
        continue;
      // int32 Channel = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool FromChannel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.fromchannel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool Review = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.review_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .symphony.proto.AccountLog LoginLog = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_loginlog(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountLoginReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.AccountLoginReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string AccountName = 1;
  if (!this->_internal_accountname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_accountname().data(), static_cast<int>(this->_internal_accountname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.AccountLoginReq.AccountName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_accountname(), target);
  }

  // string Password = 2;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.AccountLoginReq.Password");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  // int32 Channel = 3;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_channel(), target);
  }

  // bool FromChannel = 4;
  if (this->_internal_fromchannel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_fromchannel(), target);
  }

  // bool Review = 5;
  if (this->_internal_review() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_review(), target);
  }

  // .symphony.proto.AccountLog LoginLog = 6;
  if (this->_internal_has_loginlog()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::loginlog(this),
        _Internal::loginlog(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.AccountLoginReq)
  return target;
}

size_t AccountLoginReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.AccountLoginReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string AccountName = 1;
  if (!this->_internal_accountname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_accountname());
  }

  // string Password = 2;
  if (!this->_internal_password().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  // .symphony.proto.AccountLog LoginLog = 6;
  if (this->_internal_has_loginlog()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.loginlog_);
  }

  // int32 Channel = 3;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channel());
  }

  // bool FromChannel = 4;
  if (this->_internal_fromchannel() != 0) {
    total_size += 1 + 1;
  }

  // bool Review = 5;
  if (this->_internal_review() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountLoginReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountLoginReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountLoginReq::GetClassData() const { return &_class_data_; }


void AccountLoginReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountLoginReq*>(&to_msg);
  auto& from = static_cast<const AccountLoginReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.AccountLoginReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_accountname().empty()) {
    _this->_internal_set_accountname(from._internal_accountname());
  }
  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  if (from._internal_has_loginlog()) {
    _this->_internal_mutable_loginlog()->::symphony::proto::AccountLog::MergeFrom(
        from._internal_loginlog());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  if (from._internal_fromchannel() != 0) {
    _this->_internal_set_fromchannel(from._internal_fromchannel());
  }
  if (from._internal_review() != 0) {
    _this->_internal_set_review(from._internal_review());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountLoginReq::CopyFrom(const AccountLoginReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.AccountLoginReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountLoginReq::IsInitialized() const {
  return true;
}

void AccountLoginReq::InternalSwap(AccountLoginReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.accountname_, lhs_arena,
      &other->_impl_.accountname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountLoginReq, _impl_.review_)
      + sizeof(AccountLoginReq::_impl_.review_)
      - PROTOBUF_FIELD_OFFSET(AccountLoginReq, _impl_.loginlog_)>(
          reinterpret_cast<char*>(&_impl_.loginlog_),
          reinterpret_cast<char*>(&other->_impl_.loginlog_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountLoginReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[5]);
}

// ===================================================================

class AccountLoginAck::_Internal {
 public:
};

AccountLoginAck::AccountLoginAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.AccountLoginAck)
}
AccountLoginAck::AccountLoginAck(const AccountLoginAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountLoginAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.lastsvrname_){}
    , decltype(_impl_.accountid_){}
    , decltype(_impl_.retcode_){}
    , decltype(_impl_.lastsvrid_){}
    , decltype(_impl_.review_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.ipaddr_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.lastsvrname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lastsvrname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_lastsvrname().empty()) {
    _this->_impl_.lastsvrname_.Set(from._internal_lastsvrname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ipaddr_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.ipaddr_));
  // @@protoc_insertion_point(copy_constructor:symphony.proto.AccountLoginAck)
}

inline void AccountLoginAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.lastsvrname_){}
    , decltype(_impl_.accountid_){uint64_t{0u}}
    , decltype(_impl_.retcode_){0u}
    , decltype(_impl_.lastsvrid_){0}
    , decltype(_impl_.review_){false}
    , decltype(_impl_.channel_){0}
    , decltype(_impl_.ipaddr_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.lastsvrname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lastsvrname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountLoginAck::~AccountLoginAck() {
  // @@protoc_insertion_point(destructor:symphony.proto.AccountLoginAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountLoginAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.lastsvrname_.Destroy();
}

void AccountLoginAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountLoginAck::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.AccountLoginAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lastsvrname_.ClearToEmpty();
  ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.ipaddr_) -
      reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.ipaddr_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountLoginAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 RetCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.retcode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 AccountID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 LastSvrID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.lastsvrid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string LastSvrName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_lastsvrname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.AccountLoginAck.LastSvrName"));
        } else
          goto handle_unusual;
        continue;
      // bool Review = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.review_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 Channel = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 IpAddr = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.ipaddr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountLoginAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.AccountLoginAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 RetCode = 1;
  if (this->_internal_retcode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_retcode(), target);
  }

  // uint64 AccountID = 2;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_accountid(), target);
  }

  // int32 LastSvrID = 3;
  if (this->_internal_lastsvrid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_lastsvrid(), target);
  }

  // string LastSvrName = 4;
  if (!this->_internal_lastsvrname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_lastsvrname().data(), static_cast<int>(this->_internal_lastsvrname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.AccountLoginAck.LastSvrName");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_lastsvrname(), target);
  }

  // bool Review = 5;
  if (this->_internal_review() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_review(), target);
  }

  // int32 Channel = 6;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_channel(), target);
  }

  // int32 IpAddr = 7;
  if (this->_internal_ipaddr() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_ipaddr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.AccountLoginAck)
  return target;
}

size_t AccountLoginAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.AccountLoginAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string LastSvrName = 4;
  if (!this->_internal_lastsvrname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_lastsvrname());
  }

  // uint64 AccountID = 2;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  // uint32 RetCode = 1;
  if (this->_internal_retcode() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_retcode());
  }

  // int32 LastSvrID = 3;
  if (this->_internal_lastsvrid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lastsvrid());
  }

  // bool Review = 5;
  if (this->_internal_review() != 0) {
    total_size += 1 + 1;
  }

  // int32 Channel = 6;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channel());
  }

  // int32 IpAddr = 7;
  if (this->_internal_ipaddr() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ipaddr());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountLoginAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountLoginAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountLoginAck::GetClassData() const { return &_class_data_; }


void AccountLoginAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountLoginAck*>(&to_msg);
  auto& from = static_cast<const AccountLoginAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.AccountLoginAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_lastsvrname().empty()) {
    _this->_internal_set_lastsvrname(from._internal_lastsvrname());
  }
  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  if (from._internal_retcode() != 0) {
    _this->_internal_set_retcode(from._internal_retcode());
  }
  if (from._internal_lastsvrid() != 0) {
    _this->_internal_set_lastsvrid(from._internal_lastsvrid());
  }
  if (from._internal_review() != 0) {
    _this->_internal_set_review(from._internal_review());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  if (from._internal_ipaddr() != 0) {
    _this->_internal_set_ipaddr(from._internal_ipaddr());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountLoginAck::CopyFrom(const AccountLoginAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.AccountLoginAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountLoginAck::IsInitialized() const {
  return true;
}

void AccountLoginAck::InternalSwap(AccountLoginAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.lastsvrname_, lhs_arena,
      &other->_impl_.lastsvrname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountLoginAck, _impl_.ipaddr_)
      + sizeof(AccountLoginAck::_impl_.ipaddr_)
      - PROTOBUF_FIELD_OFFSET(AccountLoginAck, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountLoginAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[6]);
}

// ===================================================================

class ClientServerListReq::_Internal {
 public:
};

ClientServerListReq::ClientServerListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.ClientServerListReq)
}
ClientServerListReq::ClientServerListReq(const ClientServerListReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClientServerListReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.version_){}
    , decltype(_impl_.accountid_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.review_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.review_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.review_));
  // @@protoc_insertion_point(copy_constructor:symphony.proto.ClientServerListReq)
}

inline void ClientServerListReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.version_){}
    , decltype(_impl_.accountid_){uint64_t{0u}}
    , decltype(_impl_.channel_){0}
    , decltype(_impl_.review_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientServerListReq::~ClientServerListReq() {
  // @@protoc_insertion_point(destructor:symphony.proto.ClientServerListReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientServerListReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.version_.Destroy();
}

void ClientServerListReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientServerListReq::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.ClientServerListReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.version_.ClearToEmpty();
  ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.review_) -
      reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.review_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClientServerListReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 AccountID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 Channel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.ClientServerListReq.Version"));
        } else
          goto handle_unusual;
        continue;
      // bool Review = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.review_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientServerListReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.ClientServerListReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 AccountID = 1;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_accountid(), target);
  }

  // int32 Channel = 2;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_channel(), target);
  }

  // string Version = 3;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.ClientServerListReq.Version");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_version(), target);
  }

  // bool Review = 4;
  if (this->_internal_review() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_review(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.ClientServerListReq)
  return target;
}

size_t ClientServerListReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.ClientServerListReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Version = 3;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // uint64 AccountID = 1;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  // int32 Channel = 2;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channel());
  }

  // bool Review = 4;
  if (this->_internal_review() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClientServerListReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClientServerListReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClientServerListReq::GetClassData() const { return &_class_data_; }


void ClientServerListReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClientServerListReq*>(&to_msg);
  auto& from = static_cast<const ClientServerListReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.ClientServerListReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  if (from._internal_review() != 0) {
    _this->_internal_set_review(from._internal_review());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClientServerListReq::CopyFrom(const ClientServerListReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.ClientServerListReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientServerListReq::IsInitialized() const {
  return true;
}

void ClientServerListReq::InternalSwap(ClientServerListReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientServerListReq, _impl_.review_)
      + sizeof(ClientServerListReq::_impl_.review_)
      - PROTOBUF_FIELD_OFFSET(ClientServerListReq, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ClientServerListReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[7]);
}

// ===================================================================

class ClientServerNode::_Internal {
 public:
};

ClientServerNode::ClientServerNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.ClientServerNode)
}
ClientServerNode::ClientServerNode(const ClientServerNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClientServerNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.svrname_){}
    , decltype(_impl_.svrid_){}
    , decltype(_impl_.svrflag_){}
    , decltype(_impl_.svropentime_){}
    , decltype(_impl_.cornermark_){}
    , decltype(_impl_.svrstatus_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.svrname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.svrname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_svrname().empty()) {
    _this->_impl_.svrname_.Set(from._internal_svrname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.svrid_, &from._impl_.svrid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.svrstatus_) -
    reinterpret_cast<char*>(&_impl_.svrid_)) + sizeof(_impl_.svrstatus_));
  // @@protoc_insertion_point(copy_constructor:symphony.proto.ClientServerNode)
}

inline void ClientServerNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.svrname_){}
    , decltype(_impl_.svrid_){0}
    , decltype(_impl_.svrflag_){0}
    , decltype(_impl_.svropentime_){int64_t{0}}
    , decltype(_impl_.cornermark_){0}
    , decltype(_impl_.svrstatus_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.svrname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.svrname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientServerNode::~ClientServerNode() {
  // @@protoc_insertion_point(destructor:symphony.proto.ClientServerNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientServerNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.svrname_.Destroy();
}

void ClientServerNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientServerNode::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.ClientServerNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.svrname_.ClearToEmpty();
  ::memset(&_impl_.svrid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.svrstatus_) -
      reinterpret_cast<char*>(&_impl_.svrid_)) + sizeof(_impl_.svrstatus_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClientServerNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 SvrID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.svrid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string SvrName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_svrname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.ClientServerNode.SvrName"));
        } else
          goto handle_unusual;
        continue;
      // int32 SvrFlag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.svrflag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 CornerMark = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.cornermark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 SvrOpenTime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.svropentime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 SvrStatus = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.svrstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientServerNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.ClientServerNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 SvrID = 1;
  if (this->_internal_svrid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_svrid(), target);
  }

  // string SvrName = 2;
  if (!this->_internal_svrname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_svrname().data(), static_cast<int>(this->_internal_svrname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.ClientServerNode.SvrName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_svrname(), target);
  }

  // int32 SvrFlag = 3;
  if (this->_internal_svrflag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_svrflag(), target);
  }

  // int32 CornerMark = 4;
  if (this->_internal_cornermark() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_cornermark(), target);
  }

  // int64 SvrOpenTime = 5;
  if (this->_internal_svropentime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_svropentime(), target);
  }

  // int32 SvrStatus = 6;
  if (this->_internal_svrstatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_svrstatus(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.ClientServerNode)
  return target;
}

size_t ClientServerNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.ClientServerNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string SvrName = 2;
  if (!this->_internal_svrname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_svrname());
  }

  // int32 SvrID = 1;
  if (this->_internal_svrid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_svrid());
  }

  // int32 SvrFlag = 3;
  if (this->_internal_svrflag() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_svrflag());
  }

  // int64 SvrOpenTime = 5;
  if (this->_internal_svropentime() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_svropentime());
  }

  // int32 CornerMark = 4;
  if (this->_internal_cornermark() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cornermark());
  }

  // int32 SvrStatus = 6;
  if (this->_internal_svrstatus() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_svrstatus());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClientServerNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClientServerNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClientServerNode::GetClassData() const { return &_class_data_; }


void ClientServerNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClientServerNode*>(&to_msg);
  auto& from = static_cast<const ClientServerNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.ClientServerNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_svrname().empty()) {
    _this->_internal_set_svrname(from._internal_svrname());
  }
  if (from._internal_svrid() != 0) {
    _this->_internal_set_svrid(from._internal_svrid());
  }
  if (from._internal_svrflag() != 0) {
    _this->_internal_set_svrflag(from._internal_svrflag());
  }
  if (from._internal_svropentime() != 0) {
    _this->_internal_set_svropentime(from._internal_svropentime());
  }
  if (from._internal_cornermark() != 0) {
    _this->_internal_set_cornermark(from._internal_cornermark());
  }
  if (from._internal_svrstatus() != 0) {
    _this->_internal_set_svrstatus(from._internal_svrstatus());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClientServerNode::CopyFrom(const ClientServerNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.ClientServerNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientServerNode::IsInitialized() const {
  return true;
}

void ClientServerNode::InternalSwap(ClientServerNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.svrname_, lhs_arena,
      &other->_impl_.svrname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientServerNode, _impl_.svrstatus_)
      + sizeof(ClientServerNode::_impl_.svrstatus_)
      - PROTOBUF_FIELD_OFFSET(ClientServerNode, _impl_.svrid_)>(
          reinterpret_cast<char*>(&_impl_.svrid_),
          reinterpret_cast<char*>(&other->_impl_.svrid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ClientServerNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[8]);
}

// ===================================================================

class ClientServerListAck::_Internal {
 public:
};

ClientServerListAck::ClientServerListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.ClientServerListAck)
}
ClientServerListAck::ClientServerListAck(const ClientServerListAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClientServerListAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.svrnode_){from._impl_.svrnode_}
    , decltype(_impl_.retcode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.retcode_ = from._impl_.retcode_;
  // @@protoc_insertion_point(copy_constructor:symphony.proto.ClientServerListAck)
}

inline void ClientServerListAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.svrnode_){arena}
    , decltype(_impl_.retcode_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ClientServerListAck::~ClientServerListAck() {
  // @@protoc_insertion_point(destructor:symphony.proto.ClientServerListAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientServerListAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.svrnode_.~RepeatedPtrField();
}

void ClientServerListAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientServerListAck::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.ClientServerListAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.svrnode_.Clear();
  _impl_.retcode_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClientServerListAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 RetCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.retcode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .symphony.proto.ClientServerNode SvrNode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_svrnode(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientServerListAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.ClientServerListAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 RetCode = 1;
  if (this->_internal_retcode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_retcode(), target);
  }

  // repeated .symphony.proto.ClientServerNode SvrNode = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_svrnode_size()); i < n; i++) {
    const auto& repfield = this->_internal_svrnode(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.ClientServerListAck)
  return target;
}

size_t ClientServerListAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.ClientServerListAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .symphony.proto.ClientServerNode SvrNode = 2;
  total_size += 1UL * this->_internal_svrnode_size();
  for (const auto& msg : this->_impl_.svrnode_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 RetCode = 1;
  if (this->_internal_retcode() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_retcode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClientServerListAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClientServerListAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClientServerListAck::GetClassData() const { return &_class_data_; }


void ClientServerListAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClientServerListAck*>(&to_msg);
  auto& from = static_cast<const ClientServerListAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.ClientServerListAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.svrnode_.MergeFrom(from._impl_.svrnode_);
  if (from._internal_retcode() != 0) {
    _this->_internal_set_retcode(from._internal_retcode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClientServerListAck::CopyFrom(const ClientServerListAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.ClientServerListAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientServerListAck::IsInitialized() const {
  return true;
}

void ClientServerListAck::InternalSwap(ClientServerListAck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.svrnode_.InternalSwap(&other->_impl_.svrnode_);
  swap(_impl_.retcode_, other->_impl_.retcode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ClientServerListAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[9]);
}

// ===================================================================

class SelectServerReq::_Internal {
 public:
};

SelectServerReq::SelectServerReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.SelectServerReq)
}
SelectServerReq::SelectServerReq(const SelectServerReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SelectServerReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){}
    , decltype(_impl_.serverid_){}
    , decltype(_impl_.checkrole_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.checkrole_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.checkrole_));
  // @@protoc_insertion_point(copy_constructor:symphony.proto.SelectServerReq)
}

inline void SelectServerReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){uint64_t{0u}}
    , decltype(_impl_.serverid_){0}
    , decltype(_impl_.checkrole_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SelectServerReq::~SelectServerReq() {
  // @@protoc_insertion_point(destructor:symphony.proto.SelectServerReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectServerReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SelectServerReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SelectServerReq::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.SelectServerReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.checkrole_) -
      reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.checkrole_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SelectServerReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 AccountID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 ServerID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.serverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool CheckRole = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.checkrole_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectServerReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.SelectServerReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 AccountID = 1;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_accountid(), target);
  }

  // int32 ServerID = 2;
  if (this->_internal_serverid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_serverid(), target);
  }

  // bool CheckRole = 3;
  if (this->_internal_checkrole() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_checkrole(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.SelectServerReq)
  return target;
}

size_t SelectServerReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.SelectServerReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 AccountID = 1;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  // int32 ServerID = 2;
  if (this->_internal_serverid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_serverid());
  }

  // bool CheckRole = 3;
  if (this->_internal_checkrole() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SelectServerReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SelectServerReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SelectServerReq::GetClassData() const { return &_class_data_; }


void SelectServerReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SelectServerReq*>(&to_msg);
  auto& from = static_cast<const SelectServerReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.SelectServerReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  if (from._internal_serverid() != 0) {
    _this->_internal_set_serverid(from._internal_serverid());
  }
  if (from._internal_checkrole() != 0) {
    _this->_internal_set_checkrole(from._internal_checkrole());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SelectServerReq::CopyFrom(const SelectServerReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.SelectServerReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectServerReq::IsInitialized() const {
  return true;
}

void SelectServerReq::InternalSwap(SelectServerReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SelectServerReq, _impl_.checkrole_)
      + sizeof(SelectServerReq::_impl_.checkrole_)
      - PROTOBUF_FIELD_OFFSET(SelectServerReq, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SelectServerReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[10]);
}

// ===================================================================

class SelectServerAck::_Internal {
 public:
};

SelectServerAck::SelectServerAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.SelectServerAck)
}
SelectServerAck::SelectServerAck(const SelectServerAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SelectServerAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.serveraddr_){}
    , decltype(_impl_.accountid_){}
    , decltype(_impl_.retcode_){}
    , decltype(_impl_.serverid_){}
    , decltype(_impl_.serverport_){}
    , decltype(_impl_.logincode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.serveraddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serveraddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_serveraddr().empty()) {
    _this->_impl_.serveraddr_.Set(from._internal_serveraddr(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.logincode_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.logincode_));
  // @@protoc_insertion_point(copy_constructor:symphony.proto.SelectServerAck)
}

inline void SelectServerAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.serveraddr_){}
    , decltype(_impl_.accountid_){uint64_t{0u}}
    , decltype(_impl_.retcode_){0u}
    , decltype(_impl_.serverid_){0}
    , decltype(_impl_.serverport_){0}
    , decltype(_impl_.logincode_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.serveraddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serveraddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SelectServerAck::~SelectServerAck() {
  // @@protoc_insertion_point(destructor:symphony.proto.SelectServerAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectServerAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.serveraddr_.Destroy();
}

void SelectServerAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SelectServerAck::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.SelectServerAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.serveraddr_.ClearToEmpty();
  ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.logincode_) -
      reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.logincode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SelectServerAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 RetCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.retcode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 AccountID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 ServerID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.serverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string ServerAddr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_serveraddr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.SelectServerAck.ServerAddr"));
        } else
          goto handle_unusual;
        continue;
      // int32 ServerPort = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.serverport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 LoginCode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.logincode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectServerAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.SelectServerAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 RetCode = 1;
  if (this->_internal_retcode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_retcode(), target);
  }

  // uint64 AccountID = 2;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_accountid(), target);
  }

  // int32 ServerID = 3;
  if (this->_internal_serverid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_serverid(), target);
  }

  // string ServerAddr = 4;
  if (!this->_internal_serveraddr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_serveraddr().data(), static_cast<int>(this->_internal_serveraddr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.SelectServerAck.ServerAddr");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_serveraddr(), target);
  }

  // int32 ServerPort = 5;
  if (this->_internal_serverport() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_serverport(), target);
  }

  // int32 LoginCode = 6;
  if (this->_internal_logincode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_logincode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.SelectServerAck)
  return target;
}

size_t SelectServerAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.SelectServerAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ServerAddr = 4;
  if (!this->_internal_serveraddr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_serveraddr());
  }

  // uint64 AccountID = 2;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  // uint32 RetCode = 1;
  if (this->_internal_retcode() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_retcode());
  }

  // int32 ServerID = 3;
  if (this->_internal_serverid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_serverid());
  }

  // int32 ServerPort = 5;
  if (this->_internal_serverport() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_serverport());
  }

  // int32 LoginCode = 6;
  if (this->_internal_logincode() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_logincode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SelectServerAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SelectServerAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SelectServerAck::GetClassData() const { return &_class_data_; }


void SelectServerAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SelectServerAck*>(&to_msg);
  auto& from = static_cast<const SelectServerAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.SelectServerAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_serveraddr().empty()) {
    _this->_internal_set_serveraddr(from._internal_serveraddr());
  }
  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  if (from._internal_retcode() != 0) {
    _this->_internal_set_retcode(from._internal_retcode());
  }
  if (from._internal_serverid() != 0) {
    _this->_internal_set_serverid(from._internal_serverid());
  }
  if (from._internal_serverport() != 0) {
    _this->_internal_set_serverport(from._internal_serverport());
  }
  if (from._internal_logincode() != 0) {
    _this->_internal_set_logincode(from._internal_logincode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SelectServerAck::CopyFrom(const SelectServerAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.SelectServerAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectServerAck::IsInitialized() const {
  return true;
}

void SelectServerAck::InternalSwap(SelectServerAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serveraddr_, lhs_arena,
      &other->_impl_.serveraddr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SelectServerAck, _impl_.logincode_)
      + sizeof(SelectServerAck::_impl_.logincode_)
      - PROTOBUF_FIELD_OFFSET(SelectServerAck, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SelectServerAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[11]);
}

// ===================================================================

class SealAccountReq::_Internal {
 public:
};

SealAccountReq::SealAccountReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.SealAccountReq)
}
SealAccountReq::SealAccountReq(const SealAccountReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SealAccountReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountname_){}
    , decltype(_impl_.accountid_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.sealtime_){}
    , decltype(_impl_.seal_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.accountname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accountname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_accountname().empty()) {
    _this->_impl_.accountname_.Set(from._internal_accountname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.seal_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.seal_));
  // @@protoc_insertion_point(copy_constructor:symphony.proto.SealAccountReq)
}

inline void SealAccountReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountname_){}
    , decltype(_impl_.accountid_){uint64_t{0u}}
    , decltype(_impl_.channel_){0}
    , decltype(_impl_.sealtime_){0}
    , decltype(_impl_.seal_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.accountname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accountname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SealAccountReq::~SealAccountReq() {
  // @@protoc_insertion_point(destructor:symphony.proto.SealAccountReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SealAccountReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.accountname_.Destroy();
}

void SealAccountReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SealAccountReq::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.SealAccountReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accountname_.ClearToEmpty();
  ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.seal_) -
      reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.seal_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SealAccountReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string AccountName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_accountname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.SealAccountReq.AccountName"));
        } else
          goto handle_unusual;
        continue;
      // uint64 AccountID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 Channel = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 SealTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.sealtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool Seal = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.seal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SealAccountReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.SealAccountReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string AccountName = 1;
  if (!this->_internal_accountname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_accountname().data(), static_cast<int>(this->_internal_accountname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.SealAccountReq.AccountName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_accountname(), target);
  }

  // uint64 AccountID = 2;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_accountid(), target);
  }

  // int32 Channel = 3;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_channel(), target);
  }

  // int32 SealTime = 4;
  if (this->_internal_sealtime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_sealtime(), target);
  }

  // bool Seal = 5;
  if (this->_internal_seal() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_seal(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.SealAccountReq)
  return target;
}

size_t SealAccountReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.SealAccountReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string AccountName = 1;
  if (!this->_internal_accountname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_accountname());
  }

  // uint64 AccountID = 2;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  // int32 Channel = 3;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channel());
  }

  // int32 SealTime = 4;
  if (this->_internal_sealtime() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sealtime());
  }

  // bool Seal = 5;
  if (this->_internal_seal() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SealAccountReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SealAccountReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SealAccountReq::GetClassData() const { return &_class_data_; }


void SealAccountReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SealAccountReq*>(&to_msg);
  auto& from = static_cast<const SealAccountReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.SealAccountReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_accountname().empty()) {
    _this->_internal_set_accountname(from._internal_accountname());
  }
  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  if (from._internal_sealtime() != 0) {
    _this->_internal_set_sealtime(from._internal_sealtime());
  }
  if (from._internal_seal() != 0) {
    _this->_internal_set_seal(from._internal_seal());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SealAccountReq::CopyFrom(const SealAccountReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.SealAccountReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SealAccountReq::IsInitialized() const {
  return true;
}

void SealAccountReq::InternalSwap(SealAccountReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.accountname_, lhs_arena,
      &other->_impl_.accountname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SealAccountReq, _impl_.seal_)
      + sizeof(SealAccountReq::_impl_.seal_)
      - PROTOBUF_FIELD_OFFSET(SealAccountReq, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SealAccountReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[12]);
}

// ===================================================================

class SealAccountAck::_Internal {
 public:
};

SealAccountAck::SealAccountAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.SealAccountAck)
}
SealAccountAck::SealAccountAck(const SealAccountAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SealAccountAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountname_){}
    , decltype(_impl_.retcode_){}
    , decltype(_impl_.serverid_){}
    , decltype(_impl_.accountid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.accountname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accountname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_accountname().empty()) {
    _this->_impl_.accountname_.Set(from._internal_accountname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.retcode_, &from._impl_.retcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.accountid_) -
    reinterpret_cast<char*>(&_impl_.retcode_)) + sizeof(_impl_.accountid_));
  // @@protoc_insertion_point(copy_constructor:symphony.proto.SealAccountAck)
}

inline void SealAccountAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountname_){}
    , decltype(_impl_.retcode_){0u}
    , decltype(_impl_.serverid_){0}
    , decltype(_impl_.accountid_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.accountname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accountname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SealAccountAck::~SealAccountAck() {
  // @@protoc_insertion_point(destructor:symphony.proto.SealAccountAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SealAccountAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.accountname_.Destroy();
}

void SealAccountAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SealAccountAck::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.SealAccountAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accountname_.ClearToEmpty();
  ::memset(&_impl_.retcode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.accountid_) -
      reinterpret_cast<char*>(&_impl_.retcode_)) + sizeof(_impl_.accountid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SealAccountAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 RetCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.retcode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string AccountName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_accountname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "symphony.proto.SealAccountAck.AccountName"));
        } else
          goto handle_unusual;
        continue;
      // uint64 AccountID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 ServerID = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.serverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SealAccountAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.SealAccountAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 RetCode = 1;
  if (this->_internal_retcode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_retcode(), target);
  }

  // string AccountName = 2;
  if (!this->_internal_accountname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_accountname().data(), static_cast<int>(this->_internal_accountname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "symphony.proto.SealAccountAck.AccountName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_accountname(), target);
  }

  // uint64 AccountID = 3;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_accountid(), target);
  }

  // int32 ServerID = 4;
  if (this->_internal_serverid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_serverid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.SealAccountAck)
  return target;
}

size_t SealAccountAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.SealAccountAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string AccountName = 2;
  if (!this->_internal_accountname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_accountname());
  }

  // uint32 RetCode = 1;
  if (this->_internal_retcode() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_retcode());
  }

  // int32 ServerID = 4;
  if (this->_internal_serverid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_serverid());
  }

  // uint64 AccountID = 3;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SealAccountAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SealAccountAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SealAccountAck::GetClassData() const { return &_class_data_; }


void SealAccountAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SealAccountAck*>(&to_msg);
  auto& from = static_cast<const SealAccountAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.SealAccountAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_accountname().empty()) {
    _this->_internal_set_accountname(from._internal_accountname());
  }
  if (from._internal_retcode() != 0) {
    _this->_internal_set_retcode(from._internal_retcode());
  }
  if (from._internal_serverid() != 0) {
    _this->_internal_set_serverid(from._internal_serverid());
  }
  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SealAccountAck::CopyFrom(const SealAccountAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.SealAccountAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SealAccountAck::IsInitialized() const {
  return true;
}

void SealAccountAck::InternalSwap(SealAccountAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.accountname_, lhs_arena,
      &other->_impl_.accountname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SealAccountAck, _impl_.accountid_)
      + sizeof(SealAccountAck::_impl_.accountid_)
      - PROTOBUF_FIELD_OFFSET(SealAccountAck, _impl_.retcode_)>(
          reinterpret_cast<char*>(&_impl_.retcode_),
          reinterpret_cast<char*>(&other->_impl_.retcode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SealAccountAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[13]);
}

// ===================================================================

class SealAccountNtf::_Internal {
 public:
};

SealAccountNtf::SealAccountNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.SealAccountNtf)
}
SealAccountNtf::SealAccountNtf(const SealAccountNtf& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SealAccountNtf* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.accountid_ = from._impl_.accountid_;
  // @@protoc_insertion_point(copy_constructor:symphony.proto.SealAccountNtf)
}

inline void SealAccountNtf::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SealAccountNtf::~SealAccountNtf() {
  // @@protoc_insertion_point(destructor:symphony.proto.SealAccountNtf)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SealAccountNtf::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SealAccountNtf::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SealAccountNtf::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.SealAccountNtf)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accountid_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SealAccountNtf::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 AccountID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SealAccountNtf::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.SealAccountNtf)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 AccountID = 1;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_accountid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.SealAccountNtf)
  return target;
}

size_t SealAccountNtf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.SealAccountNtf)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 AccountID = 1;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SealAccountNtf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SealAccountNtf::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SealAccountNtf::GetClassData() const { return &_class_data_; }


void SealAccountNtf::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SealAccountNtf*>(&to_msg);
  auto& from = static_cast<const SealAccountNtf&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.SealAccountNtf)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SealAccountNtf::CopyFrom(const SealAccountNtf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.SealAccountNtf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SealAccountNtf::IsInitialized() const {
  return true;
}

void SealAccountNtf::InternalSwap(SealAccountNtf* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.accountid_, other->_impl_.accountid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SealAccountNtf::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[14]);
}

// ===================================================================

class SetLastServerNty::_Internal {
 public:
};

SetLastServerNty::SetLastServerNty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:symphony.proto.SetLastServerNty)
}
SetLastServerNty::SetLastServerNty(const SetLastServerNty& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetLastServerNty* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){}
    , decltype(_impl_.serverid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.serverid_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.serverid_));
  // @@protoc_insertion_point(copy_constructor:symphony.proto.SetLastServerNty)
}

inline void SetLastServerNty::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){uint64_t{0u}}
    , decltype(_impl_.serverid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SetLastServerNty::~SetLastServerNty() {
  // @@protoc_insertion_point(destructor:symphony.proto.SetLastServerNty)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetLastServerNty::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetLastServerNty::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetLastServerNty::Clear() {
// @@protoc_insertion_point(message_clear_start:symphony.proto.SetLastServerNty)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.serverid_) -
      reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.serverid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetLastServerNty::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 AccountID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 ServerID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.serverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetLastServerNty::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:symphony.proto.SetLastServerNty)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 AccountID = 1;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_accountid(), target);
  }

  // int32 ServerID = 2;
  if (this->_internal_serverid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_serverid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:symphony.proto.SetLastServerNty)
  return target;
}

size_t SetLastServerNty::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:symphony.proto.SetLastServerNty)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 AccountID = 1;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  // int32 ServerID = 2;
  if (this->_internal_serverid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_serverid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetLastServerNty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetLastServerNty::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetLastServerNty::GetClassData() const { return &_class_data_; }


void SetLastServerNty::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetLastServerNty*>(&to_msg);
  auto& from = static_cast<const SetLastServerNty&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:symphony.proto.SetLastServerNty)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  if (from._internal_serverid() != 0) {
    _this->_internal_set_serverid(from._internal_serverid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetLastServerNty::CopyFrom(const SetLastServerNty& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:symphony.proto.SetLastServerNty)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetLastServerNty::IsInitialized() const {
  return true;
}

void SetLastServerNty::InternalSwap(SetLastServerNty* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetLastServerNty, _impl_.serverid_)
      + sizeof(SetLastServerNty::_impl_.serverid_)
      - PROTOBUF_FIELD_OFFSET(SetLastServerNty, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetLastServerNty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_getter, &descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto_once,
      file_level_metadata_symphony_2fproto_2fmsg_5faccount_2eproto[15]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace symphony
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::symphony::proto::CheckVersionReq*
Arena::CreateMaybeMessage< ::symphony::proto::CheckVersionReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::CheckVersionReq >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::CheckVersionAck*
Arena::CreateMaybeMessage< ::symphony::proto::CheckVersionAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::CheckVersionAck >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::AccountLog*
Arena::CreateMaybeMessage< ::symphony::proto::AccountLog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::AccountLog >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::AccountRegReq*
Arena::CreateMaybeMessage< ::symphony::proto::AccountRegReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::AccountRegReq >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::AccountRegAck*
Arena::CreateMaybeMessage< ::symphony::proto::AccountRegAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::AccountRegAck >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::AccountLoginReq*
Arena::CreateMaybeMessage< ::symphony::proto::AccountLoginReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::AccountLoginReq >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::AccountLoginAck*
Arena::CreateMaybeMessage< ::symphony::proto::AccountLoginAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::AccountLoginAck >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::ClientServerListReq*
Arena::CreateMaybeMessage< ::symphony::proto::ClientServerListReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::ClientServerListReq >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::ClientServerNode*
Arena::CreateMaybeMessage< ::symphony::proto::ClientServerNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::ClientServerNode >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::ClientServerListAck*
Arena::CreateMaybeMessage< ::symphony::proto::ClientServerListAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::ClientServerListAck >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::SelectServerReq*
Arena::CreateMaybeMessage< ::symphony::proto::SelectServerReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::SelectServerReq >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::SelectServerAck*
Arena::CreateMaybeMessage< ::symphony::proto::SelectServerAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::SelectServerAck >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::SealAccountReq*
Arena::CreateMaybeMessage< ::symphony::proto::SealAccountReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::SealAccountReq >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::SealAccountAck*
Arena::CreateMaybeMessage< ::symphony::proto::SealAccountAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::SealAccountAck >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::SealAccountNtf*
Arena::CreateMaybeMessage< ::symphony::proto::SealAccountNtf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::SealAccountNtf >(arena);
}
template<> PROTOBUF_NOINLINE ::symphony::proto::SetLastServerNty*
Arena::CreateMaybeMessage< ::symphony::proto::SetLastServerNty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::symphony::proto::SetLastServerNty >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
