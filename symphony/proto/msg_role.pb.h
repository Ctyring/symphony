// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: symphony/proto/msg_role.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_symphony_2fproto_2fmsg_5frole_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_symphony_2fproto_2fmsg_5frole_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_symphony_2fproto_2fmsg_5frole_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_symphony_2fproto_2fmsg_5frole_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_symphony_2fproto_2fmsg_5frole_2eproto;
namespace symphony {
namespace proto {
class RoleCreateAck;
struct RoleCreateAckDefaultTypeInternal;
extern RoleCreateAckDefaultTypeInternal _RoleCreateAck_default_instance_;
class RoleCreateReq;
struct RoleCreateReqDefaultTypeInternal;
extern RoleCreateReqDefaultTypeInternal _RoleCreateReq_default_instance_;
class RoleDeleteAck;
struct RoleDeleteAckDefaultTypeInternal;
extern RoleDeleteAckDefaultTypeInternal _RoleDeleteAck_default_instance_;
class RoleDeleteReq;
struct RoleDeleteReqDefaultTypeInternal;
extern RoleDeleteReqDefaultTypeInternal _RoleDeleteReq_default_instance_;
class RoleItem;
struct RoleItemDefaultTypeInternal;
extern RoleItemDefaultTypeInternal _RoleItem_default_instance_;
class RoleListAck;
struct RoleListAckDefaultTypeInternal;
extern RoleListAckDefaultTypeInternal _RoleListAck_default_instance_;
class RoleListReq;
struct RoleListReqDefaultTypeInternal;
extern RoleListReqDefaultTypeInternal _RoleListReq_default_instance_;
class RoleLoginReq;
struct RoleLoginReqDefaultTypeInternal;
extern RoleLoginReqDefaultTypeInternal _RoleLoginReq_default_instance_;
class RoleLogoutAck;
struct RoleLogoutAckDefaultTypeInternal;
extern RoleLogoutAckDefaultTypeInternal _RoleLogoutAck_default_instance_;
class RoleLogoutReq;
struct RoleLogoutReqDefaultTypeInternal;
extern RoleLogoutReqDefaultTypeInternal _RoleLogoutReq_default_instance_;
class RoleOtherLoginNty;
struct RoleOtherLoginNtyDefaultTypeInternal;
extern RoleOtherLoginNtyDefaultTypeInternal _RoleOtherLoginNty_default_instance_;
}  // namespace proto
}  // namespace symphony
PROTOBUF_NAMESPACE_OPEN
template<> ::symphony::proto::RoleCreateAck* Arena::CreateMaybeMessage<::symphony::proto::RoleCreateAck>(Arena*);
template<> ::symphony::proto::RoleCreateReq* Arena::CreateMaybeMessage<::symphony::proto::RoleCreateReq>(Arena*);
template<> ::symphony::proto::RoleDeleteAck* Arena::CreateMaybeMessage<::symphony::proto::RoleDeleteAck>(Arena*);
template<> ::symphony::proto::RoleDeleteReq* Arena::CreateMaybeMessage<::symphony::proto::RoleDeleteReq>(Arena*);
template<> ::symphony::proto::RoleItem* Arena::CreateMaybeMessage<::symphony::proto::RoleItem>(Arena*);
template<> ::symphony::proto::RoleListAck* Arena::CreateMaybeMessage<::symphony::proto::RoleListAck>(Arena*);
template<> ::symphony::proto::RoleListReq* Arena::CreateMaybeMessage<::symphony::proto::RoleListReq>(Arena*);
template<> ::symphony::proto::RoleLoginReq* Arena::CreateMaybeMessage<::symphony::proto::RoleLoginReq>(Arena*);
template<> ::symphony::proto::RoleLogoutAck* Arena::CreateMaybeMessage<::symphony::proto::RoleLogoutAck>(Arena*);
template<> ::symphony::proto::RoleLogoutReq* Arena::CreateMaybeMessage<::symphony::proto::RoleLogoutReq>(Arena*);
template<> ::symphony::proto::RoleOtherLoginNty* Arena::CreateMaybeMessage<::symphony::proto::RoleOtherLoginNty>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace symphony {
namespace proto {

// ===================================================================

class RoleItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.RoleItem) */ {
 public:
  inline RoleItem() : RoleItem(nullptr) {}
  ~RoleItem() override;
  explicit PROTOBUF_CONSTEXPR RoleItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleItem(const RoleItem& from);
  RoleItem(RoleItem&& from) noexcept
    : RoleItem() {
    *this = ::std::move(from);
  }

  inline RoleItem& operator=(const RoleItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleItem& operator=(RoleItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleItem* internal_default_instance() {
    return reinterpret_cast<const RoleItem*>(
               &_RoleItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RoleItem& a, RoleItem& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleItem& from) {
    RoleItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.RoleItem";
  }
  protected:
  explicit RoleItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kRoleIDFieldNumber = 1,
    kCarrerFieldNumber = 3,
    kLevelFieldNumber = 4,
  };
  // optional string Name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint64 RoleID = 1;
  bool has_roleid() const;
  private:
  bool _internal_has_roleid() const;
  public:
  void clear_roleid();
  uint64_t roleid() const;
  void set_roleid(uint64_t value);
  private:
  uint64_t _internal_roleid() const;
  void _internal_set_roleid(uint64_t value);
  public:

  // optional int32 Carrer = 3;
  bool has_carrer() const;
  private:
  bool _internal_has_carrer() const;
  public:
  void clear_carrer();
  int32_t carrer() const;
  void set_carrer(int32_t value);
  private:
  int32_t _internal_carrer() const;
  void _internal_set_carrer(int32_t value);
  public:

  // optional int32 Level = 4;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.RoleItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t roleid_;
    int32_t carrer_;
    int32_t level_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5frole_2eproto;
};
// -------------------------------------------------------------------

class RoleListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.RoleListReq) */ {
 public:
  inline RoleListReq() : RoleListReq(nullptr) {}
  ~RoleListReq() override;
  explicit PROTOBUF_CONSTEXPR RoleListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleListReq(const RoleListReq& from);
  RoleListReq(RoleListReq&& from) noexcept
    : RoleListReq() {
    *this = ::std::move(from);
  }

  inline RoleListReq& operator=(const RoleListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleListReq& operator=(RoleListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleListReq* internal_default_instance() {
    return reinterpret_cast<const RoleListReq*>(
               &_RoleListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RoleListReq& a, RoleListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleListReq& from) {
    RoleListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.RoleListReq";
  }
  protected:
  explicit RoleListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIDFieldNumber = 1,
    kLoginCodeFieldNumber = 2,
    kServerIDFieldNumber = 3,
  };
  // optional uint64 AccountID = 1;
  bool has_accountid() const;
  private:
  bool _internal_has_accountid() const;
  public:
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // optional int32 LoginCode = 2;
  bool has_logincode() const;
  private:
  bool _internal_has_logincode() const;
  public:
  void clear_logincode();
  int32_t logincode() const;
  void set_logincode(int32_t value);
  private:
  int32_t _internal_logincode() const;
  void _internal_set_logincode(int32_t value);
  public:

  // optional uint32 ServerID = 3;
  bool has_serverid() const;
  private:
  bool _internal_has_serverid() const;
  public:
  void clear_serverid();
  uint32_t serverid() const;
  void set_serverid(uint32_t value);
  private:
  uint32_t _internal_serverid() const;
  void _internal_set_serverid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.RoleListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t accountid_;
    int32_t logincode_;
    uint32_t serverid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5frole_2eproto;
};
// -------------------------------------------------------------------

class RoleListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.RoleListAck) */ {
 public:
  inline RoleListAck() : RoleListAck(nullptr) {}
  ~RoleListAck() override;
  explicit PROTOBUF_CONSTEXPR RoleListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleListAck(const RoleListAck& from);
  RoleListAck(RoleListAck&& from) noexcept
    : RoleListAck() {
    *this = ::std::move(from);
  }

  inline RoleListAck& operator=(const RoleListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleListAck& operator=(RoleListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleListAck* internal_default_instance() {
    return reinterpret_cast<const RoleListAck*>(
               &_RoleListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RoleListAck& a, RoleListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleListAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleListAck& from) {
    RoleListAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleListAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.RoleListAck";
  }
  protected:
  explicit RoleListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleListFieldNumber = 3,
    kAccountIDFieldNumber = 2,
    kRetCodeFieldNumber = 1,
  };
  // repeated .symphony.proto.RoleItem RoleList = 3;
  int rolelist_size() const;
  private:
  int _internal_rolelist_size() const;
  public:
  void clear_rolelist();
  ::symphony::proto::RoleItem* mutable_rolelist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::symphony::proto::RoleItem >*
      mutable_rolelist();
  private:
  const ::symphony::proto::RoleItem& _internal_rolelist(int index) const;
  ::symphony::proto::RoleItem* _internal_add_rolelist();
  public:
  const ::symphony::proto::RoleItem& rolelist(int index) const;
  ::symphony::proto::RoleItem* add_rolelist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::symphony::proto::RoleItem >&
      rolelist() const;

  // optional uint64 AccountID = 2;
  bool has_accountid() const;
  private:
  bool _internal_has_accountid() const;
  public:
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // optional uint32 RetCode = 1;
  bool has_retcode() const;
  private:
  bool _internal_has_retcode() const;
  public:
  void clear_retcode();
  uint32_t retcode() const;
  void set_retcode(uint32_t value);
  private:
  uint32_t _internal_retcode() const;
  void _internal_set_retcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.RoleListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::symphony::proto::RoleItem > rolelist_;
    uint64_t accountid_;
    uint32_t retcode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5frole_2eproto;
};
// -------------------------------------------------------------------

class RoleCreateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.RoleCreateReq) */ {
 public:
  inline RoleCreateReq() : RoleCreateReq(nullptr) {}
  ~RoleCreateReq() override;
  explicit PROTOBUF_CONSTEXPR RoleCreateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleCreateReq(const RoleCreateReq& from);
  RoleCreateReq(RoleCreateReq&& from) noexcept
    : RoleCreateReq() {
    *this = ::std::move(from);
  }

  inline RoleCreateReq& operator=(const RoleCreateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleCreateReq& operator=(RoleCreateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleCreateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleCreateReq* internal_default_instance() {
    return reinterpret_cast<const RoleCreateReq*>(
               &_RoleCreateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoleCreateReq& a, RoleCreateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleCreateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleCreateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleCreateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleCreateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleCreateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleCreateReq& from) {
    RoleCreateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleCreateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.RoleCreateReq";
  }
  protected:
  explicit RoleCreateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kAccountIDFieldNumber = 1,
    kCarrerFieldNumber = 3,
    kChannelFieldNumber = 4,
  };
  // optional string Name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint64 AccountID = 1;
  bool has_accountid() const;
  private:
  bool _internal_has_accountid() const;
  public:
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // optional int32 Carrer = 3;
  bool has_carrer() const;
  private:
  bool _internal_has_carrer() const;
  public:
  void clear_carrer();
  int32_t carrer() const;
  void set_carrer(int32_t value);
  private:
  int32_t _internal_carrer() const;
  void _internal_set_carrer(int32_t value);
  public:

  // optional int32 Channel = 4;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.RoleCreateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t accountid_;
    int32_t carrer_;
    int32_t channel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5frole_2eproto;
};
// -------------------------------------------------------------------

class RoleCreateAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.RoleCreateAck) */ {
 public:
  inline RoleCreateAck() : RoleCreateAck(nullptr) {}
  ~RoleCreateAck() override;
  explicit PROTOBUF_CONSTEXPR RoleCreateAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleCreateAck(const RoleCreateAck& from);
  RoleCreateAck(RoleCreateAck&& from) noexcept
    : RoleCreateAck() {
    *this = ::std::move(from);
  }

  inline RoleCreateAck& operator=(const RoleCreateAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleCreateAck& operator=(RoleCreateAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleCreateAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleCreateAck* internal_default_instance() {
    return reinterpret_cast<const RoleCreateAck*>(
               &_RoleCreateAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RoleCreateAck& a, RoleCreateAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleCreateAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleCreateAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleCreateAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleCreateAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleCreateAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleCreateAck& from) {
    RoleCreateAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleCreateAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.RoleCreateAck";
  }
  protected:
  explicit RoleCreateAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kAccountIDFieldNumber = 2,
    kRoleIDFieldNumber = 3,
    kRetCodeFieldNumber = 1,
    kCarrerFieldNumber = 5,
  };
  // optional string Name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint64 AccountID = 2;
  bool has_accountid() const;
  private:
  bool _internal_has_accountid() const;
  public:
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // optional uint64 RoleID = 3;
  bool has_roleid() const;
  private:
  bool _internal_has_roleid() const;
  public:
  void clear_roleid();
  uint64_t roleid() const;
  void set_roleid(uint64_t value);
  private:
  uint64_t _internal_roleid() const;
  void _internal_set_roleid(uint64_t value);
  public:

  // optional uint32 RetCode = 1;
  bool has_retcode() const;
  private:
  bool _internal_has_retcode() const;
  public:
  void clear_retcode();
  uint32_t retcode() const;
  void set_retcode(uint32_t value);
  private:
  uint32_t _internal_retcode() const;
  void _internal_set_retcode(uint32_t value);
  public:

  // optional int32 Carrer = 5;
  bool has_carrer() const;
  private:
  bool _internal_has_carrer() const;
  public:
  void clear_carrer();
  int32_t carrer() const;
  void set_carrer(int32_t value);
  private:
  int32_t _internal_carrer() const;
  void _internal_set_carrer(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.RoleCreateAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t accountid_;
    uint64_t roleid_;
    uint32_t retcode_;
    int32_t carrer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5frole_2eproto;
};
// -------------------------------------------------------------------

class RoleDeleteReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.RoleDeleteReq) */ {
 public:
  inline RoleDeleteReq() : RoleDeleteReq(nullptr) {}
  ~RoleDeleteReq() override;
  explicit PROTOBUF_CONSTEXPR RoleDeleteReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleDeleteReq(const RoleDeleteReq& from);
  RoleDeleteReq(RoleDeleteReq&& from) noexcept
    : RoleDeleteReq() {
    *this = ::std::move(from);
  }

  inline RoleDeleteReq& operator=(const RoleDeleteReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleDeleteReq& operator=(RoleDeleteReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleDeleteReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleDeleteReq* internal_default_instance() {
    return reinterpret_cast<const RoleDeleteReq*>(
               &_RoleDeleteReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RoleDeleteReq& a, RoleDeleteReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleDeleteReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleDeleteReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleDeleteReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleDeleteReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleDeleteReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleDeleteReq& from) {
    RoleDeleteReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleDeleteReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.RoleDeleteReq";
  }
  protected:
  explicit RoleDeleteReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIDFieldNumber = 1,
    kRoleIDFieldNumber = 2,
  };
  // optional uint64 AccountID = 1;
  bool has_accountid() const;
  private:
  bool _internal_has_accountid() const;
  public:
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // optional uint64 RoleID = 2;
  bool has_roleid() const;
  private:
  bool _internal_has_roleid() const;
  public:
  void clear_roleid();
  uint64_t roleid() const;
  void set_roleid(uint64_t value);
  private:
  uint64_t _internal_roleid() const;
  void _internal_set_roleid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.RoleDeleteReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t accountid_;
    uint64_t roleid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5frole_2eproto;
};
// -------------------------------------------------------------------

class RoleDeleteAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.RoleDeleteAck) */ {
 public:
  inline RoleDeleteAck() : RoleDeleteAck(nullptr) {}
  ~RoleDeleteAck() override;
  explicit PROTOBUF_CONSTEXPR RoleDeleteAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleDeleteAck(const RoleDeleteAck& from);
  RoleDeleteAck(RoleDeleteAck&& from) noexcept
    : RoleDeleteAck() {
    *this = ::std::move(from);
  }

  inline RoleDeleteAck& operator=(const RoleDeleteAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleDeleteAck& operator=(RoleDeleteAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleDeleteAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleDeleteAck* internal_default_instance() {
    return reinterpret_cast<const RoleDeleteAck*>(
               &_RoleDeleteAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RoleDeleteAck& a, RoleDeleteAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleDeleteAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleDeleteAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleDeleteAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleDeleteAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleDeleteAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleDeleteAck& from) {
    RoleDeleteAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleDeleteAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.RoleDeleteAck";
  }
  protected:
  explicit RoleDeleteAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
  };
  // optional uint32 RetCode = 1;
  bool has_retcode() const;
  private:
  bool _internal_has_retcode() const;
  public:
  void clear_retcode();
  uint32_t retcode() const;
  void set_retcode(uint32_t value);
  private:
  uint32_t _internal_retcode() const;
  void _internal_set_retcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.RoleDeleteAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t retcode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5frole_2eproto;
};
// -------------------------------------------------------------------

class RoleLoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.RoleLoginReq) */ {
 public:
  inline RoleLoginReq() : RoleLoginReq(nullptr) {}
  ~RoleLoginReq() override;
  explicit PROTOBUF_CONSTEXPR RoleLoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleLoginReq(const RoleLoginReq& from);
  RoleLoginReq(RoleLoginReq&& from) noexcept
    : RoleLoginReq() {
    *this = ::std::move(from);
  }

  inline RoleLoginReq& operator=(const RoleLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleLoginReq& operator=(RoleLoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleLoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleLoginReq* internal_default_instance() {
    return reinterpret_cast<const RoleLoginReq*>(
               &_RoleLoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RoleLoginReq& a, RoleLoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleLoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleLoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleLoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleLoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleLoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleLoginReq& from) {
    RoleLoginReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleLoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.RoleLoginReq";
  }
  protected:
  explicit RoleLoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIDFieldNumber = 1,
    kRoleIDFieldNumber = 2,
    kLangIDFieldNumber = 3,
  };
  // optional uint64 AccountID = 1;
  bool has_accountid() const;
  private:
  bool _internal_has_accountid() const;
  public:
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // optional uint64 RoleID = 2;
  bool has_roleid() const;
  private:
  bool _internal_has_roleid() const;
  public:
  void clear_roleid();
  uint64_t roleid() const;
  void set_roleid(uint64_t value);
  private:
  uint64_t _internal_roleid() const;
  void _internal_set_roleid(uint64_t value);
  public:

  // optional int32 LangID = 3;
  bool has_langid() const;
  private:
  bool _internal_has_langid() const;
  public:
  void clear_langid();
  int32_t langid() const;
  void set_langid(int32_t value);
  private:
  int32_t _internal_langid() const;
  void _internal_set_langid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.RoleLoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t accountid_;
    uint64_t roleid_;
    int32_t langid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5frole_2eproto;
};
// -------------------------------------------------------------------

class RoleLogoutReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.RoleLogoutReq) */ {
 public:
  inline RoleLogoutReq() : RoleLogoutReq(nullptr) {}
  ~RoleLogoutReq() override;
  explicit PROTOBUF_CONSTEXPR RoleLogoutReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleLogoutReq(const RoleLogoutReq& from);
  RoleLogoutReq(RoleLogoutReq&& from) noexcept
    : RoleLogoutReq() {
    *this = ::std::move(from);
  }

  inline RoleLogoutReq& operator=(const RoleLogoutReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleLogoutReq& operator=(RoleLogoutReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleLogoutReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleLogoutReq* internal_default_instance() {
    return reinterpret_cast<const RoleLogoutReq*>(
               &_RoleLogoutReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RoleLogoutReq& a, RoleLogoutReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleLogoutReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleLogoutReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleLogoutReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleLogoutReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleLogoutReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleLogoutReq& from) {
    RoleLogoutReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleLogoutReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.RoleLogoutReq";
  }
  protected:
  explicit RoleLogoutReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIDFieldNumber = 1,
  };
  // optional uint64 AccountID = 1;
  bool has_accountid() const;
  private:
  bool _internal_has_accountid() const;
  public:
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.RoleLogoutReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t accountid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5frole_2eproto;
};
// -------------------------------------------------------------------

class RoleLogoutAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.RoleLogoutAck) */ {
 public:
  inline RoleLogoutAck() : RoleLogoutAck(nullptr) {}
  ~RoleLogoutAck() override;
  explicit PROTOBUF_CONSTEXPR RoleLogoutAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleLogoutAck(const RoleLogoutAck& from);
  RoleLogoutAck(RoleLogoutAck&& from) noexcept
    : RoleLogoutAck() {
    *this = ::std::move(from);
  }

  inline RoleLogoutAck& operator=(const RoleLogoutAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleLogoutAck& operator=(RoleLogoutAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleLogoutAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleLogoutAck* internal_default_instance() {
    return reinterpret_cast<const RoleLogoutAck*>(
               &_RoleLogoutAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RoleLogoutAck& a, RoleLogoutAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleLogoutAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleLogoutAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleLogoutAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleLogoutAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleLogoutAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleLogoutAck& from) {
    RoleLogoutAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleLogoutAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.RoleLogoutAck";
  }
  protected:
  explicit RoleLogoutAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
  };
  // optional uint32 RetCode = 1;
  bool has_retcode() const;
  private:
  bool _internal_has_retcode() const;
  public:
  void clear_retcode();
  uint32_t retcode() const;
  void set_retcode(uint32_t value);
  private:
  uint32_t _internal_retcode() const;
  void _internal_set_retcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.RoleLogoutAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t retcode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5frole_2eproto;
};
// -------------------------------------------------------------------

class RoleOtherLoginNty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.RoleOtherLoginNty) */ {
 public:
  inline RoleOtherLoginNty() : RoleOtherLoginNty(nullptr) {}
  ~RoleOtherLoginNty() override;
  explicit PROTOBUF_CONSTEXPR RoleOtherLoginNty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleOtherLoginNty(const RoleOtherLoginNty& from);
  RoleOtherLoginNty(RoleOtherLoginNty&& from) noexcept
    : RoleOtherLoginNty() {
    *this = ::std::move(from);
  }

  inline RoleOtherLoginNty& operator=(const RoleOtherLoginNty& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleOtherLoginNty& operator=(RoleOtherLoginNty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleOtherLoginNty& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleOtherLoginNty* internal_default_instance() {
    return reinterpret_cast<const RoleOtherLoginNty*>(
               &_RoleOtherLoginNty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RoleOtherLoginNty& a, RoleOtherLoginNty& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleOtherLoginNty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleOtherLoginNty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleOtherLoginNty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleOtherLoginNty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleOtherLoginNty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleOtherLoginNty& from) {
    RoleOtherLoginNty::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleOtherLoginNty* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.RoleOtherLoginNty";
  }
  protected:
  explicit RoleOtherLoginNty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetCodeFieldNumber = 1,
  };
  // optional uint32 RetCode = 1;
  bool has_retcode() const;
  private:
  bool _internal_has_retcode() const;
  public:
  void clear_retcode();
  uint32_t retcode() const;
  void set_retcode(uint32_t value);
  private:
  uint32_t _internal_retcode() const;
  void _internal_set_retcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.RoleOtherLoginNty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t retcode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5frole_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoleItem

// optional uint64 RoleID = 1;
inline bool RoleItem::_internal_has_roleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RoleItem::has_roleid() const {
  return _internal_has_roleid();
}
inline void RoleItem::clear_roleid() {
  _impl_.roleid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t RoleItem::_internal_roleid() const {
  return _impl_.roleid_;
}
inline uint64_t RoleItem::roleid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleItem.RoleID)
  return _internal_roleid();
}
inline void RoleItem::_internal_set_roleid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.roleid_ = value;
}
inline void RoleItem::set_roleid(uint64_t value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleItem.RoleID)
}

// optional string Name = 2;
inline bool RoleItem::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoleItem::has_name() const {
  return _internal_has_name();
}
inline void RoleItem::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoleItem::name() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleItem.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoleItem::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.RoleItem.Name)
}
inline std::string* RoleItem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:symphony.proto.RoleItem.Name)
  return _s;
}
inline const std::string& RoleItem::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RoleItem::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RoleItem::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RoleItem::release_name() {
  // @@protoc_insertion_point(field_release:symphony.proto.RoleItem.Name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RoleItem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.RoleItem.Name)
}

// optional int32 Carrer = 3;
inline bool RoleItem::_internal_has_carrer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RoleItem::has_carrer() const {
  return _internal_has_carrer();
}
inline void RoleItem::clear_carrer() {
  _impl_.carrer_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t RoleItem::_internal_carrer() const {
  return _impl_.carrer_;
}
inline int32_t RoleItem::carrer() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleItem.Carrer)
  return _internal_carrer();
}
inline void RoleItem::_internal_set_carrer(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.carrer_ = value;
}
inline void RoleItem::set_carrer(int32_t value) {
  _internal_set_carrer(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleItem.Carrer)
}

// optional int32 Level = 4;
inline bool RoleItem::_internal_has_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RoleItem::has_level() const {
  return _internal_has_level();
}
inline void RoleItem::clear_level() {
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t RoleItem::_internal_level() const {
  return _impl_.level_;
}
inline int32_t RoleItem::level() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleItem.Level)
  return _internal_level();
}
inline void RoleItem::_internal_set_level(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.level_ = value;
}
inline void RoleItem::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleItem.Level)
}

// -------------------------------------------------------------------

// RoleListReq

// optional uint64 AccountID = 1;
inline bool RoleListReq::_internal_has_accountid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoleListReq::has_accountid() const {
  return _internal_has_accountid();
}
inline void RoleListReq::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t RoleListReq::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t RoleListReq::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleListReq.AccountID)
  return _internal_accountid();
}
inline void RoleListReq::_internal_set_accountid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.accountid_ = value;
}
inline void RoleListReq::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleListReq.AccountID)
}

// optional int32 LoginCode = 2;
inline bool RoleListReq::_internal_has_logincode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RoleListReq::has_logincode() const {
  return _internal_has_logincode();
}
inline void RoleListReq::clear_logincode() {
  _impl_.logincode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t RoleListReq::_internal_logincode() const {
  return _impl_.logincode_;
}
inline int32_t RoleListReq::logincode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleListReq.LoginCode)
  return _internal_logincode();
}
inline void RoleListReq::_internal_set_logincode(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.logincode_ = value;
}
inline void RoleListReq::set_logincode(int32_t value) {
  _internal_set_logincode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleListReq.LoginCode)
}

// optional uint32 ServerID = 3;
inline bool RoleListReq::_internal_has_serverid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RoleListReq::has_serverid() const {
  return _internal_has_serverid();
}
inline void RoleListReq::clear_serverid() {
  _impl_.serverid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RoleListReq::_internal_serverid() const {
  return _impl_.serverid_;
}
inline uint32_t RoleListReq::serverid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleListReq.ServerID)
  return _internal_serverid();
}
inline void RoleListReq::_internal_set_serverid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.serverid_ = value;
}
inline void RoleListReq::set_serverid(uint32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleListReq.ServerID)
}

// -------------------------------------------------------------------

// RoleListAck

// optional uint32 RetCode = 1;
inline bool RoleListAck::_internal_has_retcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RoleListAck::has_retcode() const {
  return _internal_has_retcode();
}
inline void RoleListAck::clear_retcode() {
  _impl_.retcode_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RoleListAck::_internal_retcode() const {
  return _impl_.retcode_;
}
inline uint32_t RoleListAck::retcode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleListAck.RetCode)
  return _internal_retcode();
}
inline void RoleListAck::_internal_set_retcode(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.retcode_ = value;
}
inline void RoleListAck::set_retcode(uint32_t value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleListAck.RetCode)
}

// optional uint64 AccountID = 2;
inline bool RoleListAck::_internal_has_accountid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoleListAck::has_accountid() const {
  return _internal_has_accountid();
}
inline void RoleListAck::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t RoleListAck::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t RoleListAck::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleListAck.AccountID)
  return _internal_accountid();
}
inline void RoleListAck::_internal_set_accountid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.accountid_ = value;
}
inline void RoleListAck::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleListAck.AccountID)
}

// repeated .symphony.proto.RoleItem RoleList = 3;
inline int RoleListAck::_internal_rolelist_size() const {
  return _impl_.rolelist_.size();
}
inline int RoleListAck::rolelist_size() const {
  return _internal_rolelist_size();
}
inline void RoleListAck::clear_rolelist() {
  _impl_.rolelist_.Clear();
}
inline ::symphony::proto::RoleItem* RoleListAck::mutable_rolelist(int index) {
  // @@protoc_insertion_point(field_mutable:symphony.proto.RoleListAck.RoleList)
  return _impl_.rolelist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::symphony::proto::RoleItem >*
RoleListAck::mutable_rolelist() {
  // @@protoc_insertion_point(field_mutable_list:symphony.proto.RoleListAck.RoleList)
  return &_impl_.rolelist_;
}
inline const ::symphony::proto::RoleItem& RoleListAck::_internal_rolelist(int index) const {
  return _impl_.rolelist_.Get(index);
}
inline const ::symphony::proto::RoleItem& RoleListAck::rolelist(int index) const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleListAck.RoleList)
  return _internal_rolelist(index);
}
inline ::symphony::proto::RoleItem* RoleListAck::_internal_add_rolelist() {
  return _impl_.rolelist_.Add();
}
inline ::symphony::proto::RoleItem* RoleListAck::add_rolelist() {
  ::symphony::proto::RoleItem* _add = _internal_add_rolelist();
  // @@protoc_insertion_point(field_add:symphony.proto.RoleListAck.RoleList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::symphony::proto::RoleItem >&
RoleListAck::rolelist() const {
  // @@protoc_insertion_point(field_list:symphony.proto.RoleListAck.RoleList)
  return _impl_.rolelist_;
}

// -------------------------------------------------------------------

// RoleCreateReq

// optional uint64 AccountID = 1;
inline bool RoleCreateReq::_internal_has_accountid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RoleCreateReq::has_accountid() const {
  return _internal_has_accountid();
}
inline void RoleCreateReq::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t RoleCreateReq::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t RoleCreateReq::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleCreateReq.AccountID)
  return _internal_accountid();
}
inline void RoleCreateReq::_internal_set_accountid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.accountid_ = value;
}
inline void RoleCreateReq::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleCreateReq.AccountID)
}

// optional string Name = 2;
inline bool RoleCreateReq::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoleCreateReq::has_name() const {
  return _internal_has_name();
}
inline void RoleCreateReq::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoleCreateReq::name() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleCreateReq.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoleCreateReq::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.RoleCreateReq.Name)
}
inline std::string* RoleCreateReq::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:symphony.proto.RoleCreateReq.Name)
  return _s;
}
inline const std::string& RoleCreateReq::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RoleCreateReq::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RoleCreateReq::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RoleCreateReq::release_name() {
  // @@protoc_insertion_point(field_release:symphony.proto.RoleCreateReq.Name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RoleCreateReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.RoleCreateReq.Name)
}

// optional int32 Carrer = 3;
inline bool RoleCreateReq::_internal_has_carrer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RoleCreateReq::has_carrer() const {
  return _internal_has_carrer();
}
inline void RoleCreateReq::clear_carrer() {
  _impl_.carrer_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t RoleCreateReq::_internal_carrer() const {
  return _impl_.carrer_;
}
inline int32_t RoleCreateReq::carrer() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleCreateReq.Carrer)
  return _internal_carrer();
}
inline void RoleCreateReq::_internal_set_carrer(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.carrer_ = value;
}
inline void RoleCreateReq::set_carrer(int32_t value) {
  _internal_set_carrer(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleCreateReq.Carrer)
}

// optional int32 Channel = 4;
inline bool RoleCreateReq::_internal_has_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RoleCreateReq::has_channel() const {
  return _internal_has_channel();
}
inline void RoleCreateReq::clear_channel() {
  _impl_.channel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t RoleCreateReq::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t RoleCreateReq::channel() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleCreateReq.Channel)
  return _internal_channel();
}
inline void RoleCreateReq::_internal_set_channel(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.channel_ = value;
}
inline void RoleCreateReq::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleCreateReq.Channel)
}

// -------------------------------------------------------------------

// RoleCreateAck

// optional uint32 RetCode = 1;
inline bool RoleCreateAck::_internal_has_retcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RoleCreateAck::has_retcode() const {
  return _internal_has_retcode();
}
inline void RoleCreateAck::clear_retcode() {
  _impl_.retcode_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RoleCreateAck::_internal_retcode() const {
  return _impl_.retcode_;
}
inline uint32_t RoleCreateAck::retcode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleCreateAck.RetCode)
  return _internal_retcode();
}
inline void RoleCreateAck::_internal_set_retcode(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.retcode_ = value;
}
inline void RoleCreateAck::set_retcode(uint32_t value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleCreateAck.RetCode)
}

// optional uint64 AccountID = 2;
inline bool RoleCreateAck::_internal_has_accountid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RoleCreateAck::has_accountid() const {
  return _internal_has_accountid();
}
inline void RoleCreateAck::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t RoleCreateAck::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t RoleCreateAck::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleCreateAck.AccountID)
  return _internal_accountid();
}
inline void RoleCreateAck::_internal_set_accountid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.accountid_ = value;
}
inline void RoleCreateAck::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleCreateAck.AccountID)
}

// optional uint64 RoleID = 3;
inline bool RoleCreateAck::_internal_has_roleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RoleCreateAck::has_roleid() const {
  return _internal_has_roleid();
}
inline void RoleCreateAck::clear_roleid() {
  _impl_.roleid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t RoleCreateAck::_internal_roleid() const {
  return _impl_.roleid_;
}
inline uint64_t RoleCreateAck::roleid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleCreateAck.RoleID)
  return _internal_roleid();
}
inline void RoleCreateAck::_internal_set_roleid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.roleid_ = value;
}
inline void RoleCreateAck::set_roleid(uint64_t value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleCreateAck.RoleID)
}

// optional string Name = 4;
inline bool RoleCreateAck::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoleCreateAck::has_name() const {
  return _internal_has_name();
}
inline void RoleCreateAck::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoleCreateAck::name() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleCreateAck.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoleCreateAck::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.RoleCreateAck.Name)
}
inline std::string* RoleCreateAck::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:symphony.proto.RoleCreateAck.Name)
  return _s;
}
inline const std::string& RoleCreateAck::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RoleCreateAck::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RoleCreateAck::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RoleCreateAck::release_name() {
  // @@protoc_insertion_point(field_release:symphony.proto.RoleCreateAck.Name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RoleCreateAck::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.RoleCreateAck.Name)
}

// optional int32 Carrer = 5;
inline bool RoleCreateAck::_internal_has_carrer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RoleCreateAck::has_carrer() const {
  return _internal_has_carrer();
}
inline void RoleCreateAck::clear_carrer() {
  _impl_.carrer_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t RoleCreateAck::_internal_carrer() const {
  return _impl_.carrer_;
}
inline int32_t RoleCreateAck::carrer() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleCreateAck.Carrer)
  return _internal_carrer();
}
inline void RoleCreateAck::_internal_set_carrer(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.carrer_ = value;
}
inline void RoleCreateAck::set_carrer(int32_t value) {
  _internal_set_carrer(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleCreateAck.Carrer)
}

// -------------------------------------------------------------------

// RoleDeleteReq

// optional uint64 AccountID = 1;
inline bool RoleDeleteReq::_internal_has_accountid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoleDeleteReq::has_accountid() const {
  return _internal_has_accountid();
}
inline void RoleDeleteReq::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t RoleDeleteReq::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t RoleDeleteReq::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleDeleteReq.AccountID)
  return _internal_accountid();
}
inline void RoleDeleteReq::_internal_set_accountid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.accountid_ = value;
}
inline void RoleDeleteReq::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleDeleteReq.AccountID)
}

// optional uint64 RoleID = 2;
inline bool RoleDeleteReq::_internal_has_roleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RoleDeleteReq::has_roleid() const {
  return _internal_has_roleid();
}
inline void RoleDeleteReq::clear_roleid() {
  _impl_.roleid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t RoleDeleteReq::_internal_roleid() const {
  return _impl_.roleid_;
}
inline uint64_t RoleDeleteReq::roleid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleDeleteReq.RoleID)
  return _internal_roleid();
}
inline void RoleDeleteReq::_internal_set_roleid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.roleid_ = value;
}
inline void RoleDeleteReq::set_roleid(uint64_t value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleDeleteReq.RoleID)
}

// -------------------------------------------------------------------

// RoleDeleteAck

// optional uint32 RetCode = 1;
inline bool RoleDeleteAck::_internal_has_retcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoleDeleteAck::has_retcode() const {
  return _internal_has_retcode();
}
inline void RoleDeleteAck::clear_retcode() {
  _impl_.retcode_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t RoleDeleteAck::_internal_retcode() const {
  return _impl_.retcode_;
}
inline uint32_t RoleDeleteAck::retcode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleDeleteAck.RetCode)
  return _internal_retcode();
}
inline void RoleDeleteAck::_internal_set_retcode(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.retcode_ = value;
}
inline void RoleDeleteAck::set_retcode(uint32_t value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleDeleteAck.RetCode)
}

// -------------------------------------------------------------------

// RoleLoginReq

// optional uint64 AccountID = 1;
inline bool RoleLoginReq::_internal_has_accountid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoleLoginReq::has_accountid() const {
  return _internal_has_accountid();
}
inline void RoleLoginReq::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t RoleLoginReq::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t RoleLoginReq::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleLoginReq.AccountID)
  return _internal_accountid();
}
inline void RoleLoginReq::_internal_set_accountid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.accountid_ = value;
}
inline void RoleLoginReq::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleLoginReq.AccountID)
}

// optional uint64 RoleID = 2;
inline bool RoleLoginReq::_internal_has_roleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RoleLoginReq::has_roleid() const {
  return _internal_has_roleid();
}
inline void RoleLoginReq::clear_roleid() {
  _impl_.roleid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t RoleLoginReq::_internal_roleid() const {
  return _impl_.roleid_;
}
inline uint64_t RoleLoginReq::roleid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleLoginReq.RoleID)
  return _internal_roleid();
}
inline void RoleLoginReq::_internal_set_roleid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.roleid_ = value;
}
inline void RoleLoginReq::set_roleid(uint64_t value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleLoginReq.RoleID)
}

// optional int32 LangID = 3;
inline bool RoleLoginReq::_internal_has_langid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RoleLoginReq::has_langid() const {
  return _internal_has_langid();
}
inline void RoleLoginReq::clear_langid() {
  _impl_.langid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t RoleLoginReq::_internal_langid() const {
  return _impl_.langid_;
}
inline int32_t RoleLoginReq::langid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleLoginReq.LangID)
  return _internal_langid();
}
inline void RoleLoginReq::_internal_set_langid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.langid_ = value;
}
inline void RoleLoginReq::set_langid(int32_t value) {
  _internal_set_langid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleLoginReq.LangID)
}

// -------------------------------------------------------------------

// RoleLogoutReq

// optional uint64 AccountID = 1;
inline bool RoleLogoutReq::_internal_has_accountid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoleLogoutReq::has_accountid() const {
  return _internal_has_accountid();
}
inline void RoleLogoutReq::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t RoleLogoutReq::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t RoleLogoutReq::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleLogoutReq.AccountID)
  return _internal_accountid();
}
inline void RoleLogoutReq::_internal_set_accountid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.accountid_ = value;
}
inline void RoleLogoutReq::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleLogoutReq.AccountID)
}

// -------------------------------------------------------------------

// RoleLogoutAck

// optional uint32 RetCode = 1;
inline bool RoleLogoutAck::_internal_has_retcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoleLogoutAck::has_retcode() const {
  return _internal_has_retcode();
}
inline void RoleLogoutAck::clear_retcode() {
  _impl_.retcode_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t RoleLogoutAck::_internal_retcode() const {
  return _impl_.retcode_;
}
inline uint32_t RoleLogoutAck::retcode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleLogoutAck.RetCode)
  return _internal_retcode();
}
inline void RoleLogoutAck::_internal_set_retcode(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.retcode_ = value;
}
inline void RoleLogoutAck::set_retcode(uint32_t value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleLogoutAck.RetCode)
}

// -------------------------------------------------------------------

// RoleOtherLoginNty

// optional uint32 RetCode = 1;
inline bool RoleOtherLoginNty::_internal_has_retcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoleOtherLoginNty::has_retcode() const {
  return _internal_has_retcode();
}
inline void RoleOtherLoginNty::clear_retcode() {
  _impl_.retcode_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t RoleOtherLoginNty::_internal_retcode() const {
  return _impl_.retcode_;
}
inline uint32_t RoleOtherLoginNty::retcode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.RoleOtherLoginNty.RetCode)
  return _internal_retcode();
}
inline void RoleOtherLoginNty::_internal_set_retcode(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.retcode_ = value;
}
inline void RoleOtherLoginNty::set_retcode(uint32_t value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.RoleOtherLoginNty.RetCode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace symphony

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_symphony_2fproto_2fmsg_5frole_2eproto
