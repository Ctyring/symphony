// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: symphony/proto/msg_account.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_symphony_2fproto_2fmsg_5faccount_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_symphony_2fproto_2fmsg_5faccount_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_symphony_2fproto_2fmsg_5faccount_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_symphony_2fproto_2fmsg_5faccount_2eproto;
namespace symphony {
namespace proto {
class AccountLog;
struct AccountLogDefaultTypeInternal;
extern AccountLogDefaultTypeInternal _AccountLog_default_instance_;
class AccountLoginAck;
struct AccountLoginAckDefaultTypeInternal;
extern AccountLoginAckDefaultTypeInternal _AccountLoginAck_default_instance_;
class AccountLoginReq;
struct AccountLoginReqDefaultTypeInternal;
extern AccountLoginReqDefaultTypeInternal _AccountLoginReq_default_instance_;
class AccountRegAck;
struct AccountRegAckDefaultTypeInternal;
extern AccountRegAckDefaultTypeInternal _AccountRegAck_default_instance_;
class AccountRegReq;
struct AccountRegReqDefaultTypeInternal;
extern AccountRegReqDefaultTypeInternal _AccountRegReq_default_instance_;
class CheckVersionAck;
struct CheckVersionAckDefaultTypeInternal;
extern CheckVersionAckDefaultTypeInternal _CheckVersionAck_default_instance_;
class CheckVersionReq;
struct CheckVersionReqDefaultTypeInternal;
extern CheckVersionReqDefaultTypeInternal _CheckVersionReq_default_instance_;
class ClientServerListAck;
struct ClientServerListAckDefaultTypeInternal;
extern ClientServerListAckDefaultTypeInternal _ClientServerListAck_default_instance_;
class ClientServerListReq;
struct ClientServerListReqDefaultTypeInternal;
extern ClientServerListReqDefaultTypeInternal _ClientServerListReq_default_instance_;
class ClientServerNode;
struct ClientServerNodeDefaultTypeInternal;
extern ClientServerNodeDefaultTypeInternal _ClientServerNode_default_instance_;
class SealAccountAck;
struct SealAccountAckDefaultTypeInternal;
extern SealAccountAckDefaultTypeInternal _SealAccountAck_default_instance_;
class SealAccountNtf;
struct SealAccountNtfDefaultTypeInternal;
extern SealAccountNtfDefaultTypeInternal _SealAccountNtf_default_instance_;
class SealAccountReq;
struct SealAccountReqDefaultTypeInternal;
extern SealAccountReqDefaultTypeInternal _SealAccountReq_default_instance_;
class SelectServerAck;
struct SelectServerAckDefaultTypeInternal;
extern SelectServerAckDefaultTypeInternal _SelectServerAck_default_instance_;
class SelectServerReq;
struct SelectServerReqDefaultTypeInternal;
extern SelectServerReqDefaultTypeInternal _SelectServerReq_default_instance_;
class SetLastServerNty;
struct SetLastServerNtyDefaultTypeInternal;
extern SetLastServerNtyDefaultTypeInternal _SetLastServerNty_default_instance_;
}  // namespace proto
}  // namespace symphony
PROTOBUF_NAMESPACE_OPEN
template<> ::symphony::proto::AccountLog* Arena::CreateMaybeMessage<::symphony::proto::AccountLog>(Arena*);
template<> ::symphony::proto::AccountLoginAck* Arena::CreateMaybeMessage<::symphony::proto::AccountLoginAck>(Arena*);
template<> ::symphony::proto::AccountLoginReq* Arena::CreateMaybeMessage<::symphony::proto::AccountLoginReq>(Arena*);
template<> ::symphony::proto::AccountRegAck* Arena::CreateMaybeMessage<::symphony::proto::AccountRegAck>(Arena*);
template<> ::symphony::proto::AccountRegReq* Arena::CreateMaybeMessage<::symphony::proto::AccountRegReq>(Arena*);
template<> ::symphony::proto::CheckVersionAck* Arena::CreateMaybeMessage<::symphony::proto::CheckVersionAck>(Arena*);
template<> ::symphony::proto::CheckVersionReq* Arena::CreateMaybeMessage<::symphony::proto::CheckVersionReq>(Arena*);
template<> ::symphony::proto::ClientServerListAck* Arena::CreateMaybeMessage<::symphony::proto::ClientServerListAck>(Arena*);
template<> ::symphony::proto::ClientServerListReq* Arena::CreateMaybeMessage<::symphony::proto::ClientServerListReq>(Arena*);
template<> ::symphony::proto::ClientServerNode* Arena::CreateMaybeMessage<::symphony::proto::ClientServerNode>(Arena*);
template<> ::symphony::proto::SealAccountAck* Arena::CreateMaybeMessage<::symphony::proto::SealAccountAck>(Arena*);
template<> ::symphony::proto::SealAccountNtf* Arena::CreateMaybeMessage<::symphony::proto::SealAccountNtf>(Arena*);
template<> ::symphony::proto::SealAccountReq* Arena::CreateMaybeMessage<::symphony::proto::SealAccountReq>(Arena*);
template<> ::symphony::proto::SelectServerAck* Arena::CreateMaybeMessage<::symphony::proto::SelectServerAck>(Arena*);
template<> ::symphony::proto::SelectServerReq* Arena::CreateMaybeMessage<::symphony::proto::SelectServerReq>(Arena*);
template<> ::symphony::proto::SetLastServerNty* Arena::CreateMaybeMessage<::symphony::proto::SetLastServerNty>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace symphony {
namespace proto {

// ===================================================================

class CheckVersionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.CheckVersionReq) */ {
 public:
  inline CheckVersionReq() : CheckVersionReq(nullptr) {}
  ~CheckVersionReq() override;
  explicit PROTOBUF_CONSTEXPR CheckVersionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckVersionReq(const CheckVersionReq& from);
  CheckVersionReq(CheckVersionReq&& from) noexcept
    : CheckVersionReq() {
    *this = ::std::move(from);
  }

  inline CheckVersionReq& operator=(const CheckVersionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckVersionReq& operator=(CheckVersionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckVersionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckVersionReq* internal_default_instance() {
    return reinterpret_cast<const CheckVersionReq*>(
               &_CheckVersionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CheckVersionReq& a, CheckVersionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckVersionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckVersionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckVersionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckVersionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckVersionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckVersionReq& from) {
    CheckVersionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckVersionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.CheckVersionReq";
  }
  protected:
  explicit CheckVersionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientVerionFieldNumber = 1,
    kChannelFieldNumber = 2,
  };
  // string ClientVerion = 1;
  void clear_clientverion();
  const std::string& clientverion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientverion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientverion();
  PROTOBUF_NODISCARD std::string* release_clientverion();
  void set_allocated_clientverion(std::string* clientverion);
  private:
  const std::string& _internal_clientverion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientverion(const std::string& value);
  std::string* _internal_mutable_clientverion();
  public:

  // int32 Channel = 2;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.CheckVersionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientverion_;
    int32_t channel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class CheckVersionAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.CheckVersionAck) */ {
 public:
  inline CheckVersionAck() : CheckVersionAck(nullptr) {}
  ~CheckVersionAck() override;
  explicit PROTOBUF_CONSTEXPR CheckVersionAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckVersionAck(const CheckVersionAck& from);
  CheckVersionAck(CheckVersionAck&& from) noexcept
    : CheckVersionAck() {
    *this = ::std::move(from);
  }

  inline CheckVersionAck& operator=(const CheckVersionAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckVersionAck& operator=(CheckVersionAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckVersionAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckVersionAck* internal_default_instance() {
    return reinterpret_cast<const CheckVersionAck*>(
               &_CheckVersionAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CheckVersionAck& a, CheckVersionAck& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckVersionAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckVersionAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckVersionAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckVersionAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckVersionAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckVersionAck& from) {
    CheckVersionAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckVersionAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.CheckVersionAck";
  }
  protected:
  explicit CheckVersionAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientVerionFieldNumber = 2,
    kRetCodeFieldNumber = 1,
  };
  // string ClientVerion = 2;
  void clear_clientverion();
  const std::string& clientverion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientverion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientverion();
  PROTOBUF_NODISCARD std::string* release_clientverion();
  void set_allocated_clientverion(std::string* clientverion);
  private:
  const std::string& _internal_clientverion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientverion(const std::string& value);
  std::string* _internal_mutable_clientverion();
  public:

  // uint32 RetCode = 1;
  void clear_retcode();
  uint32_t retcode() const;
  void set_retcode(uint32_t value);
  private:
  uint32_t _internal_retcode() const;
  void _internal_set_retcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.CheckVersionAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientverion_;
    uint32_t retcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class AccountLog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.AccountLog) */ {
 public:
  inline AccountLog() : AccountLog(nullptr) {}
  ~AccountLog() override;
  explicit PROTOBUF_CONSTEXPR AccountLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountLog(const AccountLog& from);
  AccountLog(AccountLog&& from) noexcept
    : AccountLog() {
    *this = ::std::move(from);
  }

  inline AccountLog& operator=(const AccountLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountLog& operator=(AccountLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountLog* internal_default_instance() {
    return reinterpret_cast<const AccountLog*>(
               &_AccountLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AccountLog& a, AccountLog& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountLog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountLog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountLog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountLog& from) {
    AccountLog::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountLog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.AccountLog";
  }
  protected:
  explicit AccountLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kUuidFieldNumber = 4,
    kIdfaFieldNumber = 5,
    kImodelFieldNumber = 6,
    kImeiFieldNumber = 7,
    kAccountIDFieldNumber = 3,
    kChannelFieldNumber = 1,
    kIpAddrFieldNumber = 8,
  };
  // string Version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string Uuid = 4;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // string Idfa = 5;
  void clear_idfa();
  const std::string& idfa() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idfa(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idfa();
  PROTOBUF_NODISCARD std::string* release_idfa();
  void set_allocated_idfa(std::string* idfa);
  private:
  const std::string& _internal_idfa() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idfa(const std::string& value);
  std::string* _internal_mutable_idfa();
  public:

  // string Imodel = 6;
  void clear_imodel();
  const std::string& imodel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imodel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imodel();
  PROTOBUF_NODISCARD std::string* release_imodel();
  void set_allocated_imodel(std::string* imodel);
  private:
  const std::string& _internal_imodel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imodel(const std::string& value);
  std::string* _internal_mutable_imodel();
  public:

  // string Imei = 7;
  void clear_imei();
  const std::string& imei() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imei(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imei();
  PROTOBUF_NODISCARD std::string* release_imei();
  void set_allocated_imei(std::string* imei);
  private:
  const std::string& _internal_imei() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imei(const std::string& value);
  std::string* _internal_mutable_imei();
  public:

  // uint64 AccountID = 3;
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // int32 Channel = 1;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // int32 IpAddr = 8;
  void clear_ipaddr();
  int32_t ipaddr() const;
  void set_ipaddr(int32_t value);
  private:
  int32_t _internal_ipaddr() const;
  void _internal_set_ipaddr(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.AccountLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idfa_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imodel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imei_;
    uint64_t accountid_;
    int32_t channel_;
    int32_t ipaddr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class AccountRegReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.AccountRegReq) */ {
 public:
  inline AccountRegReq() : AccountRegReq(nullptr) {}
  ~AccountRegReq() override;
  explicit PROTOBUF_CONSTEXPR AccountRegReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountRegReq(const AccountRegReq& from);
  AccountRegReq(AccountRegReq&& from) noexcept
    : AccountRegReq() {
    *this = ::std::move(from);
  }

  inline AccountRegReq& operator=(const AccountRegReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountRegReq& operator=(AccountRegReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountRegReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountRegReq* internal_default_instance() {
    return reinterpret_cast<const AccountRegReq*>(
               &_AccountRegReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AccountRegReq& a, AccountRegReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountRegReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountRegReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountRegReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountRegReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountRegReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountRegReq& from) {
    AccountRegReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountRegReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.AccountRegReq";
  }
  protected:
  explicit AccountRegReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kRegLogFieldNumber = 4,
    kChannelFieldNumber = 3,
  };
  // string AccountName = 1;
  void clear_accountname();
  const std::string& accountname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accountname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accountname();
  PROTOBUF_NODISCARD std::string* release_accountname();
  void set_allocated_accountname(std::string* accountname);
  private:
  const std::string& _internal_accountname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accountname(const std::string& value);
  std::string* _internal_mutable_accountname();
  public:

  // string Password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .symphony.proto.AccountLog RegLog = 4;
  bool has_reglog() const;
  private:
  bool _internal_has_reglog() const;
  public:
  void clear_reglog();
  const ::symphony::proto::AccountLog& reglog() const;
  PROTOBUF_NODISCARD ::symphony::proto::AccountLog* release_reglog();
  ::symphony::proto::AccountLog* mutable_reglog();
  void set_allocated_reglog(::symphony::proto::AccountLog* reglog);
  private:
  const ::symphony::proto::AccountLog& _internal_reglog() const;
  ::symphony::proto::AccountLog* _internal_mutable_reglog();
  public:
  void unsafe_arena_set_allocated_reglog(
      ::symphony::proto::AccountLog* reglog);
  ::symphony::proto::AccountLog* unsafe_arena_release_reglog();

  // int32 Channel = 3;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.AccountRegReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accountname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::symphony::proto::AccountLog* reglog_;
    int32_t channel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class AccountRegAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.AccountRegAck) */ {
 public:
  inline AccountRegAck() : AccountRegAck(nullptr) {}
  ~AccountRegAck() override;
  explicit PROTOBUF_CONSTEXPR AccountRegAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountRegAck(const AccountRegAck& from);
  AccountRegAck(AccountRegAck&& from) noexcept
    : AccountRegAck() {
    *this = ::std::move(from);
  }

  inline AccountRegAck& operator=(const AccountRegAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountRegAck& operator=(AccountRegAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountRegAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountRegAck* internal_default_instance() {
    return reinterpret_cast<const AccountRegAck*>(
               &_AccountRegAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AccountRegAck& a, AccountRegAck& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountRegAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountRegAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountRegAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountRegAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountRegAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountRegAck& from) {
    AccountRegAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountRegAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.AccountRegAck";
  }
  protected:
  explicit AccountRegAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIDFieldNumber = 2,
    kRetCodeFieldNumber = 1,
  };
  // uint64 AccountID = 2;
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // uint32 RetCode = 1;
  void clear_retcode();
  uint32_t retcode() const;
  void set_retcode(uint32_t value);
  private:
  uint32_t _internal_retcode() const;
  void _internal_set_retcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.AccountRegAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t accountid_;
    uint32_t retcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class AccountLoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.AccountLoginReq) */ {
 public:
  inline AccountLoginReq() : AccountLoginReq(nullptr) {}
  ~AccountLoginReq() override;
  explicit PROTOBUF_CONSTEXPR AccountLoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountLoginReq(const AccountLoginReq& from);
  AccountLoginReq(AccountLoginReq&& from) noexcept
    : AccountLoginReq() {
    *this = ::std::move(from);
  }

  inline AccountLoginReq& operator=(const AccountLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountLoginReq& operator=(AccountLoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountLoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountLoginReq* internal_default_instance() {
    return reinterpret_cast<const AccountLoginReq*>(
               &_AccountLoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AccountLoginReq& a, AccountLoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountLoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountLoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountLoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountLoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountLoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountLoginReq& from) {
    AccountLoginReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountLoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.AccountLoginReq";
  }
  protected:
  explicit AccountLoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kLoginLogFieldNumber = 6,
    kChannelFieldNumber = 3,
    kFromChannelFieldNumber = 4,
    kReviewFieldNumber = 5,
  };
  // string AccountName = 1;
  void clear_accountname();
  const std::string& accountname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accountname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accountname();
  PROTOBUF_NODISCARD std::string* release_accountname();
  void set_allocated_accountname(std::string* accountname);
  private:
  const std::string& _internal_accountname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accountname(const std::string& value);
  std::string* _internal_mutable_accountname();
  public:

  // string Password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .symphony.proto.AccountLog LoginLog = 6;
  bool has_loginlog() const;
  private:
  bool _internal_has_loginlog() const;
  public:
  void clear_loginlog();
  const ::symphony::proto::AccountLog& loginlog() const;
  PROTOBUF_NODISCARD ::symphony::proto::AccountLog* release_loginlog();
  ::symphony::proto::AccountLog* mutable_loginlog();
  void set_allocated_loginlog(::symphony::proto::AccountLog* loginlog);
  private:
  const ::symphony::proto::AccountLog& _internal_loginlog() const;
  ::symphony::proto::AccountLog* _internal_mutable_loginlog();
  public:
  void unsafe_arena_set_allocated_loginlog(
      ::symphony::proto::AccountLog* loginlog);
  ::symphony::proto::AccountLog* unsafe_arena_release_loginlog();

  // int32 Channel = 3;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // bool FromChannel = 4;
  void clear_fromchannel();
  bool fromchannel() const;
  void set_fromchannel(bool value);
  private:
  bool _internal_fromchannel() const;
  void _internal_set_fromchannel(bool value);
  public:

  // bool Review = 5;
  void clear_review();
  bool review() const;
  void set_review(bool value);
  private:
  bool _internal_review() const;
  void _internal_set_review(bool value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.AccountLoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accountname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::symphony::proto::AccountLog* loginlog_;
    int32_t channel_;
    bool fromchannel_;
    bool review_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class AccountLoginAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.AccountLoginAck) */ {
 public:
  inline AccountLoginAck() : AccountLoginAck(nullptr) {}
  ~AccountLoginAck() override;
  explicit PROTOBUF_CONSTEXPR AccountLoginAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountLoginAck(const AccountLoginAck& from);
  AccountLoginAck(AccountLoginAck&& from) noexcept
    : AccountLoginAck() {
    *this = ::std::move(from);
  }

  inline AccountLoginAck& operator=(const AccountLoginAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountLoginAck& operator=(AccountLoginAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountLoginAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountLoginAck* internal_default_instance() {
    return reinterpret_cast<const AccountLoginAck*>(
               &_AccountLoginAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AccountLoginAck& a, AccountLoginAck& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountLoginAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountLoginAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountLoginAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountLoginAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountLoginAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountLoginAck& from) {
    AccountLoginAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountLoginAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.AccountLoginAck";
  }
  protected:
  explicit AccountLoginAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastSvrNameFieldNumber = 4,
    kAccountIDFieldNumber = 2,
    kRetCodeFieldNumber = 1,
    kLastSvrIDFieldNumber = 3,
    kReviewFieldNumber = 5,
    kChannelFieldNumber = 6,
    kIpAddrFieldNumber = 7,
  };
  // string LastSvrName = 4;
  void clear_lastsvrname();
  const std::string& lastsvrname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lastsvrname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lastsvrname();
  PROTOBUF_NODISCARD std::string* release_lastsvrname();
  void set_allocated_lastsvrname(std::string* lastsvrname);
  private:
  const std::string& _internal_lastsvrname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lastsvrname(const std::string& value);
  std::string* _internal_mutable_lastsvrname();
  public:

  // uint64 AccountID = 2;
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // uint32 RetCode = 1;
  void clear_retcode();
  uint32_t retcode() const;
  void set_retcode(uint32_t value);
  private:
  uint32_t _internal_retcode() const;
  void _internal_set_retcode(uint32_t value);
  public:

  // int32 LastSvrID = 3;
  void clear_lastsvrid();
  int32_t lastsvrid() const;
  void set_lastsvrid(int32_t value);
  private:
  int32_t _internal_lastsvrid() const;
  void _internal_set_lastsvrid(int32_t value);
  public:

  // bool Review = 5;
  void clear_review();
  bool review() const;
  void set_review(bool value);
  private:
  bool _internal_review() const;
  void _internal_set_review(bool value);
  public:

  // int32 Channel = 6;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // int32 IpAddr = 7;
  void clear_ipaddr();
  int32_t ipaddr() const;
  void set_ipaddr(int32_t value);
  private:
  int32_t _internal_ipaddr() const;
  void _internal_set_ipaddr(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.AccountLoginAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lastsvrname_;
    uint64_t accountid_;
    uint32_t retcode_;
    int32_t lastsvrid_;
    bool review_;
    int32_t channel_;
    int32_t ipaddr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class ClientServerListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.ClientServerListReq) */ {
 public:
  inline ClientServerListReq() : ClientServerListReq(nullptr) {}
  ~ClientServerListReq() override;
  explicit PROTOBUF_CONSTEXPR ClientServerListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientServerListReq(const ClientServerListReq& from);
  ClientServerListReq(ClientServerListReq&& from) noexcept
    : ClientServerListReq() {
    *this = ::std::move(from);
  }

  inline ClientServerListReq& operator=(const ClientServerListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientServerListReq& operator=(ClientServerListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientServerListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientServerListReq* internal_default_instance() {
    return reinterpret_cast<const ClientServerListReq*>(
               &_ClientServerListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ClientServerListReq& a, ClientServerListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientServerListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientServerListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientServerListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientServerListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientServerListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientServerListReq& from) {
    ClientServerListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientServerListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.ClientServerListReq";
  }
  protected:
  explicit ClientServerListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 3,
    kAccountIDFieldNumber = 1,
    kChannelFieldNumber = 2,
    kReviewFieldNumber = 4,
  };
  // string Version = 3;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint64 AccountID = 1;
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // int32 Channel = 2;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // bool Review = 4;
  void clear_review();
  bool review() const;
  void set_review(bool value);
  private:
  bool _internal_review() const;
  void _internal_set_review(bool value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.ClientServerListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    uint64_t accountid_;
    int32_t channel_;
    bool review_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class ClientServerNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.ClientServerNode) */ {
 public:
  inline ClientServerNode() : ClientServerNode(nullptr) {}
  ~ClientServerNode() override;
  explicit PROTOBUF_CONSTEXPR ClientServerNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientServerNode(const ClientServerNode& from);
  ClientServerNode(ClientServerNode&& from) noexcept
    : ClientServerNode() {
    *this = ::std::move(from);
  }

  inline ClientServerNode& operator=(const ClientServerNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientServerNode& operator=(ClientServerNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientServerNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientServerNode* internal_default_instance() {
    return reinterpret_cast<const ClientServerNode*>(
               &_ClientServerNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ClientServerNode& a, ClientServerNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientServerNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientServerNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientServerNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientServerNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientServerNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientServerNode& from) {
    ClientServerNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientServerNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.ClientServerNode";
  }
  protected:
  explicit ClientServerNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSvrNameFieldNumber = 2,
    kSvrIDFieldNumber = 1,
    kSvrFlagFieldNumber = 3,
    kSvrOpenTimeFieldNumber = 5,
    kCornerMarkFieldNumber = 4,
    kSvrStatusFieldNumber = 6,
  };
  // string SvrName = 2;
  void clear_svrname();
  const std::string& svrname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_svrname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_svrname();
  PROTOBUF_NODISCARD std::string* release_svrname();
  void set_allocated_svrname(std::string* svrname);
  private:
  const std::string& _internal_svrname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_svrname(const std::string& value);
  std::string* _internal_mutable_svrname();
  public:

  // int32 SvrID = 1;
  void clear_svrid();
  int32_t svrid() const;
  void set_svrid(int32_t value);
  private:
  int32_t _internal_svrid() const;
  void _internal_set_svrid(int32_t value);
  public:

  // int32 SvrFlag = 3;
  void clear_svrflag();
  int32_t svrflag() const;
  void set_svrflag(int32_t value);
  private:
  int32_t _internal_svrflag() const;
  void _internal_set_svrflag(int32_t value);
  public:

  // int64 SvrOpenTime = 5;
  void clear_svropentime();
  int64_t svropentime() const;
  void set_svropentime(int64_t value);
  private:
  int64_t _internal_svropentime() const;
  void _internal_set_svropentime(int64_t value);
  public:

  // int32 CornerMark = 4;
  void clear_cornermark();
  int32_t cornermark() const;
  void set_cornermark(int32_t value);
  private:
  int32_t _internal_cornermark() const;
  void _internal_set_cornermark(int32_t value);
  public:

  // int32 SvrStatus = 6;
  void clear_svrstatus();
  int32_t svrstatus() const;
  void set_svrstatus(int32_t value);
  private:
  int32_t _internal_svrstatus() const;
  void _internal_set_svrstatus(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.ClientServerNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr svrname_;
    int32_t svrid_;
    int32_t svrflag_;
    int64_t svropentime_;
    int32_t cornermark_;
    int32_t svrstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class ClientServerListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.ClientServerListAck) */ {
 public:
  inline ClientServerListAck() : ClientServerListAck(nullptr) {}
  ~ClientServerListAck() override;
  explicit PROTOBUF_CONSTEXPR ClientServerListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientServerListAck(const ClientServerListAck& from);
  ClientServerListAck(ClientServerListAck&& from) noexcept
    : ClientServerListAck() {
    *this = ::std::move(from);
  }

  inline ClientServerListAck& operator=(const ClientServerListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientServerListAck& operator=(ClientServerListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientServerListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientServerListAck* internal_default_instance() {
    return reinterpret_cast<const ClientServerListAck*>(
               &_ClientServerListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClientServerListAck& a, ClientServerListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientServerListAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientServerListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientServerListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientServerListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientServerListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientServerListAck& from) {
    ClientServerListAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientServerListAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.ClientServerListAck";
  }
  protected:
  explicit ClientServerListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSvrNodeFieldNumber = 2,
    kRetCodeFieldNumber = 1,
  };
  // repeated .symphony.proto.ClientServerNode SvrNode = 2;
  int svrnode_size() const;
  private:
  int _internal_svrnode_size() const;
  public:
  void clear_svrnode();
  ::symphony::proto::ClientServerNode* mutable_svrnode(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::symphony::proto::ClientServerNode >*
      mutable_svrnode();
  private:
  const ::symphony::proto::ClientServerNode& _internal_svrnode(int index) const;
  ::symphony::proto::ClientServerNode* _internal_add_svrnode();
  public:
  const ::symphony::proto::ClientServerNode& svrnode(int index) const;
  ::symphony::proto::ClientServerNode* add_svrnode();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::symphony::proto::ClientServerNode >&
      svrnode() const;

  // uint32 RetCode = 1;
  void clear_retcode();
  uint32_t retcode() const;
  void set_retcode(uint32_t value);
  private:
  uint32_t _internal_retcode() const;
  void _internal_set_retcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.ClientServerListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::symphony::proto::ClientServerNode > svrnode_;
    uint32_t retcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class SelectServerReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.SelectServerReq) */ {
 public:
  inline SelectServerReq() : SelectServerReq(nullptr) {}
  ~SelectServerReq() override;
  explicit PROTOBUF_CONSTEXPR SelectServerReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectServerReq(const SelectServerReq& from);
  SelectServerReq(SelectServerReq&& from) noexcept
    : SelectServerReq() {
    *this = ::std::move(from);
  }

  inline SelectServerReq& operator=(const SelectServerReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectServerReq& operator=(SelectServerReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectServerReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectServerReq* internal_default_instance() {
    return reinterpret_cast<const SelectServerReq*>(
               &_SelectServerReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SelectServerReq& a, SelectServerReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectServerReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectServerReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectServerReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectServerReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectServerReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectServerReq& from) {
    SelectServerReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectServerReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.SelectServerReq";
  }
  protected:
  explicit SelectServerReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIDFieldNumber = 1,
    kServerIDFieldNumber = 2,
    kCheckRoleFieldNumber = 3,
  };
  // uint64 AccountID = 1;
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // int32 ServerID = 2;
  void clear_serverid();
  int32_t serverid() const;
  void set_serverid(int32_t value);
  private:
  int32_t _internal_serverid() const;
  void _internal_set_serverid(int32_t value);
  public:

  // bool CheckRole = 3;
  void clear_checkrole();
  bool checkrole() const;
  void set_checkrole(bool value);
  private:
  bool _internal_checkrole() const;
  void _internal_set_checkrole(bool value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.SelectServerReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t accountid_;
    int32_t serverid_;
    bool checkrole_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class SelectServerAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.SelectServerAck) */ {
 public:
  inline SelectServerAck() : SelectServerAck(nullptr) {}
  ~SelectServerAck() override;
  explicit PROTOBUF_CONSTEXPR SelectServerAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectServerAck(const SelectServerAck& from);
  SelectServerAck(SelectServerAck&& from) noexcept
    : SelectServerAck() {
    *this = ::std::move(from);
  }

  inline SelectServerAck& operator=(const SelectServerAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectServerAck& operator=(SelectServerAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectServerAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectServerAck* internal_default_instance() {
    return reinterpret_cast<const SelectServerAck*>(
               &_SelectServerAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SelectServerAck& a, SelectServerAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectServerAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectServerAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectServerAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectServerAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectServerAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectServerAck& from) {
    SelectServerAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectServerAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.SelectServerAck";
  }
  protected:
  explicit SelectServerAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerAddrFieldNumber = 4,
    kAccountIDFieldNumber = 2,
    kRetCodeFieldNumber = 1,
    kServerIDFieldNumber = 3,
    kServerPortFieldNumber = 5,
    kLoginCodeFieldNumber = 6,
  };
  // string ServerAddr = 4;
  void clear_serveraddr();
  const std::string& serveraddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serveraddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serveraddr();
  PROTOBUF_NODISCARD std::string* release_serveraddr();
  void set_allocated_serveraddr(std::string* serveraddr);
  private:
  const std::string& _internal_serveraddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serveraddr(const std::string& value);
  std::string* _internal_mutable_serveraddr();
  public:

  // uint64 AccountID = 2;
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // uint32 RetCode = 1;
  void clear_retcode();
  uint32_t retcode() const;
  void set_retcode(uint32_t value);
  private:
  uint32_t _internal_retcode() const;
  void _internal_set_retcode(uint32_t value);
  public:

  // int32 ServerID = 3;
  void clear_serverid();
  int32_t serverid() const;
  void set_serverid(int32_t value);
  private:
  int32_t _internal_serverid() const;
  void _internal_set_serverid(int32_t value);
  public:

  // int32 ServerPort = 5;
  void clear_serverport();
  int32_t serverport() const;
  void set_serverport(int32_t value);
  private:
  int32_t _internal_serverport() const;
  void _internal_set_serverport(int32_t value);
  public:

  // int32 LoginCode = 6;
  void clear_logincode();
  int32_t logincode() const;
  void set_logincode(int32_t value);
  private:
  int32_t _internal_logincode() const;
  void _internal_set_logincode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.SelectServerAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serveraddr_;
    uint64_t accountid_;
    uint32_t retcode_;
    int32_t serverid_;
    int32_t serverport_;
    int32_t logincode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class SealAccountReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.SealAccountReq) */ {
 public:
  inline SealAccountReq() : SealAccountReq(nullptr) {}
  ~SealAccountReq() override;
  explicit PROTOBUF_CONSTEXPR SealAccountReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SealAccountReq(const SealAccountReq& from);
  SealAccountReq(SealAccountReq&& from) noexcept
    : SealAccountReq() {
    *this = ::std::move(from);
  }

  inline SealAccountReq& operator=(const SealAccountReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SealAccountReq& operator=(SealAccountReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SealAccountReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SealAccountReq* internal_default_instance() {
    return reinterpret_cast<const SealAccountReq*>(
               &_SealAccountReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SealAccountReq& a, SealAccountReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SealAccountReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SealAccountReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SealAccountReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SealAccountReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SealAccountReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SealAccountReq& from) {
    SealAccountReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SealAccountReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.SealAccountReq";
  }
  protected:
  explicit SealAccountReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 1,
    kAccountIDFieldNumber = 2,
    kChannelFieldNumber = 3,
    kSealTimeFieldNumber = 4,
    kSealFieldNumber = 5,
  };
  // string AccountName = 1;
  void clear_accountname();
  const std::string& accountname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accountname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accountname();
  PROTOBUF_NODISCARD std::string* release_accountname();
  void set_allocated_accountname(std::string* accountname);
  private:
  const std::string& _internal_accountname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accountname(const std::string& value);
  std::string* _internal_mutable_accountname();
  public:

  // uint64 AccountID = 2;
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // int32 Channel = 3;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // int32 SealTime = 4;
  void clear_sealtime();
  int32_t sealtime() const;
  void set_sealtime(int32_t value);
  private:
  int32_t _internal_sealtime() const;
  void _internal_set_sealtime(int32_t value);
  public:

  // bool Seal = 5;
  void clear_seal();
  bool seal() const;
  void set_seal(bool value);
  private:
  bool _internal_seal() const;
  void _internal_set_seal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.SealAccountReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accountname_;
    uint64_t accountid_;
    int32_t channel_;
    int32_t sealtime_;
    bool seal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class SealAccountAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.SealAccountAck) */ {
 public:
  inline SealAccountAck() : SealAccountAck(nullptr) {}
  ~SealAccountAck() override;
  explicit PROTOBUF_CONSTEXPR SealAccountAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SealAccountAck(const SealAccountAck& from);
  SealAccountAck(SealAccountAck&& from) noexcept
    : SealAccountAck() {
    *this = ::std::move(from);
  }

  inline SealAccountAck& operator=(const SealAccountAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SealAccountAck& operator=(SealAccountAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SealAccountAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SealAccountAck* internal_default_instance() {
    return reinterpret_cast<const SealAccountAck*>(
               &_SealAccountAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SealAccountAck& a, SealAccountAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SealAccountAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SealAccountAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SealAccountAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SealAccountAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SealAccountAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SealAccountAck& from) {
    SealAccountAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SealAccountAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.SealAccountAck";
  }
  protected:
  explicit SealAccountAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 2,
    kRetCodeFieldNumber = 1,
    kServerIDFieldNumber = 4,
    kAccountIDFieldNumber = 3,
  };
  // string AccountName = 2;
  void clear_accountname();
  const std::string& accountname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accountname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accountname();
  PROTOBUF_NODISCARD std::string* release_accountname();
  void set_allocated_accountname(std::string* accountname);
  private:
  const std::string& _internal_accountname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accountname(const std::string& value);
  std::string* _internal_mutable_accountname();
  public:

  // uint32 RetCode = 1;
  void clear_retcode();
  uint32_t retcode() const;
  void set_retcode(uint32_t value);
  private:
  uint32_t _internal_retcode() const;
  void _internal_set_retcode(uint32_t value);
  public:

  // int32 ServerID = 4;
  void clear_serverid();
  int32_t serverid() const;
  void set_serverid(int32_t value);
  private:
  int32_t _internal_serverid() const;
  void _internal_set_serverid(int32_t value);
  public:

  // uint64 AccountID = 3;
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.SealAccountAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accountname_;
    uint32_t retcode_;
    int32_t serverid_;
    uint64_t accountid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class SealAccountNtf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.SealAccountNtf) */ {
 public:
  inline SealAccountNtf() : SealAccountNtf(nullptr) {}
  ~SealAccountNtf() override;
  explicit PROTOBUF_CONSTEXPR SealAccountNtf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SealAccountNtf(const SealAccountNtf& from);
  SealAccountNtf(SealAccountNtf&& from) noexcept
    : SealAccountNtf() {
    *this = ::std::move(from);
  }

  inline SealAccountNtf& operator=(const SealAccountNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline SealAccountNtf& operator=(SealAccountNtf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SealAccountNtf& default_instance() {
    return *internal_default_instance();
  }
  static inline const SealAccountNtf* internal_default_instance() {
    return reinterpret_cast<const SealAccountNtf*>(
               &_SealAccountNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SealAccountNtf& a, SealAccountNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(SealAccountNtf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SealAccountNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SealAccountNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SealAccountNtf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SealAccountNtf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SealAccountNtf& from) {
    SealAccountNtf::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SealAccountNtf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.SealAccountNtf";
  }
  protected:
  explicit SealAccountNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIDFieldNumber = 1,
  };
  // uint64 AccountID = 1;
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.SealAccountNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t accountid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// -------------------------------------------------------------------

class SetLastServerNty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:symphony.proto.SetLastServerNty) */ {
 public:
  inline SetLastServerNty() : SetLastServerNty(nullptr) {}
  ~SetLastServerNty() override;
  explicit PROTOBUF_CONSTEXPR SetLastServerNty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLastServerNty(const SetLastServerNty& from);
  SetLastServerNty(SetLastServerNty&& from) noexcept
    : SetLastServerNty() {
    *this = ::std::move(from);
  }

  inline SetLastServerNty& operator=(const SetLastServerNty& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLastServerNty& operator=(SetLastServerNty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLastServerNty& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLastServerNty* internal_default_instance() {
    return reinterpret_cast<const SetLastServerNty*>(
               &_SetLastServerNty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SetLastServerNty& a, SetLastServerNty& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLastServerNty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLastServerNty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLastServerNty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLastServerNty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLastServerNty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLastServerNty& from) {
    SetLastServerNty::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLastServerNty* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "symphony.proto.SetLastServerNty";
  }
  protected:
  explicit SetLastServerNty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIDFieldNumber = 1,
    kServerIDFieldNumber = 2,
  };
  // uint64 AccountID = 1;
  void clear_accountid();
  uint64_t accountid() const;
  void set_accountid(uint64_t value);
  private:
  uint64_t _internal_accountid() const;
  void _internal_set_accountid(uint64_t value);
  public:

  // int32 ServerID = 2;
  void clear_serverid();
  int32_t serverid() const;
  void set_serverid(int32_t value);
  private:
  int32_t _internal_serverid() const;
  void _internal_set_serverid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:symphony.proto.SetLastServerNty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t accountid_;
    int32_t serverid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_symphony_2fproto_2fmsg_5faccount_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CheckVersionReq

// string ClientVerion = 1;
inline void CheckVersionReq::clear_clientverion() {
  _impl_.clientverion_.ClearToEmpty();
}
inline const std::string& CheckVersionReq::clientverion() const {
  // @@protoc_insertion_point(field_get:symphony.proto.CheckVersionReq.ClientVerion)
  return _internal_clientverion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckVersionReq::set_clientverion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientverion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.CheckVersionReq.ClientVerion)
}
inline std::string* CheckVersionReq::mutable_clientverion() {
  std::string* _s = _internal_mutable_clientverion();
  // @@protoc_insertion_point(field_mutable:symphony.proto.CheckVersionReq.ClientVerion)
  return _s;
}
inline const std::string& CheckVersionReq::_internal_clientverion() const {
  return _impl_.clientverion_.Get();
}
inline void CheckVersionReq::_internal_set_clientverion(const std::string& value) {
  
  _impl_.clientverion_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckVersionReq::_internal_mutable_clientverion() {
  
  return _impl_.clientverion_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckVersionReq::release_clientverion() {
  // @@protoc_insertion_point(field_release:symphony.proto.CheckVersionReq.ClientVerion)
  return _impl_.clientverion_.Release();
}
inline void CheckVersionReq::set_allocated_clientverion(std::string* clientverion) {
  if (clientverion != nullptr) {
    
  } else {
    
  }
  _impl_.clientverion_.SetAllocated(clientverion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientverion_.IsDefault()) {
    _impl_.clientverion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.CheckVersionReq.ClientVerion)
}

// int32 Channel = 2;
inline void CheckVersionReq::clear_channel() {
  _impl_.channel_ = 0;
}
inline int32_t CheckVersionReq::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t CheckVersionReq::channel() const {
  // @@protoc_insertion_point(field_get:symphony.proto.CheckVersionReq.Channel)
  return _internal_channel();
}
inline void CheckVersionReq::_internal_set_channel(int32_t value) {
  
  _impl_.channel_ = value;
}
inline void CheckVersionReq::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:symphony.proto.CheckVersionReq.Channel)
}

// -------------------------------------------------------------------

// CheckVersionAck

// uint32 RetCode = 1;
inline void CheckVersionAck::clear_retcode() {
  _impl_.retcode_ = 0u;
}
inline uint32_t CheckVersionAck::_internal_retcode() const {
  return _impl_.retcode_;
}
inline uint32_t CheckVersionAck::retcode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.CheckVersionAck.RetCode)
  return _internal_retcode();
}
inline void CheckVersionAck::_internal_set_retcode(uint32_t value) {
  
  _impl_.retcode_ = value;
}
inline void CheckVersionAck::set_retcode(uint32_t value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.CheckVersionAck.RetCode)
}

// string ClientVerion = 2;
inline void CheckVersionAck::clear_clientverion() {
  _impl_.clientverion_.ClearToEmpty();
}
inline const std::string& CheckVersionAck::clientverion() const {
  // @@protoc_insertion_point(field_get:symphony.proto.CheckVersionAck.ClientVerion)
  return _internal_clientverion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckVersionAck::set_clientverion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientverion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.CheckVersionAck.ClientVerion)
}
inline std::string* CheckVersionAck::mutable_clientverion() {
  std::string* _s = _internal_mutable_clientverion();
  // @@protoc_insertion_point(field_mutable:symphony.proto.CheckVersionAck.ClientVerion)
  return _s;
}
inline const std::string& CheckVersionAck::_internal_clientverion() const {
  return _impl_.clientverion_.Get();
}
inline void CheckVersionAck::_internal_set_clientverion(const std::string& value) {
  
  _impl_.clientverion_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckVersionAck::_internal_mutable_clientverion() {
  
  return _impl_.clientverion_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckVersionAck::release_clientverion() {
  // @@protoc_insertion_point(field_release:symphony.proto.CheckVersionAck.ClientVerion)
  return _impl_.clientverion_.Release();
}
inline void CheckVersionAck::set_allocated_clientverion(std::string* clientverion) {
  if (clientverion != nullptr) {
    
  } else {
    
  }
  _impl_.clientverion_.SetAllocated(clientverion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientverion_.IsDefault()) {
    _impl_.clientverion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.CheckVersionAck.ClientVerion)
}

// -------------------------------------------------------------------

// AccountLog

// int32 Channel = 1;
inline void AccountLog::clear_channel() {
  _impl_.channel_ = 0;
}
inline int32_t AccountLog::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t AccountLog::channel() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLog.Channel)
  return _internal_channel();
}
inline void AccountLog::_internal_set_channel(int32_t value) {
  
  _impl_.channel_ = value;
}
inline void AccountLog::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLog.Channel)
}

// string Version = 2;
inline void AccountLog::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& AccountLog::version() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLog.Version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountLog::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLog.Version)
}
inline std::string* AccountLog::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:symphony.proto.AccountLog.Version)
  return _s;
}
inline const std::string& AccountLog::_internal_version() const {
  return _impl_.version_.Get();
}
inline void AccountLog::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountLog::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountLog::release_version() {
  // @@protoc_insertion_point(field_release:symphony.proto.AccountLog.Version)
  return _impl_.version_.Release();
}
inline void AccountLog::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.AccountLog.Version)
}

// uint64 AccountID = 3;
inline void AccountLog::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
}
inline uint64_t AccountLog::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t AccountLog::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLog.AccountID)
  return _internal_accountid();
}
inline void AccountLog::_internal_set_accountid(uint64_t value) {
  
  _impl_.accountid_ = value;
}
inline void AccountLog::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLog.AccountID)
}

// string Uuid = 4;
inline void AccountLog::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& AccountLog::uuid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLog.Uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountLog::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLog.Uuid)
}
inline std::string* AccountLog::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:symphony.proto.AccountLog.Uuid)
  return _s;
}
inline const std::string& AccountLog::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void AccountLog::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountLog::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountLog::release_uuid() {
  // @@protoc_insertion_point(field_release:symphony.proto.AccountLog.Uuid)
  return _impl_.uuid_.Release();
}
inline void AccountLog::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.AccountLog.Uuid)
}

// string Idfa = 5;
inline void AccountLog::clear_idfa() {
  _impl_.idfa_.ClearToEmpty();
}
inline const std::string& AccountLog::idfa() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLog.Idfa)
  return _internal_idfa();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountLog::set_idfa(ArgT0&& arg0, ArgT... args) {
 
 _impl_.idfa_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLog.Idfa)
}
inline std::string* AccountLog::mutable_idfa() {
  std::string* _s = _internal_mutable_idfa();
  // @@protoc_insertion_point(field_mutable:symphony.proto.AccountLog.Idfa)
  return _s;
}
inline const std::string& AccountLog::_internal_idfa() const {
  return _impl_.idfa_.Get();
}
inline void AccountLog::_internal_set_idfa(const std::string& value) {
  
  _impl_.idfa_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountLog::_internal_mutable_idfa() {
  
  return _impl_.idfa_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountLog::release_idfa() {
  // @@protoc_insertion_point(field_release:symphony.proto.AccountLog.Idfa)
  return _impl_.idfa_.Release();
}
inline void AccountLog::set_allocated_idfa(std::string* idfa) {
  if (idfa != nullptr) {
    
  } else {
    
  }
  _impl_.idfa_.SetAllocated(idfa, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.idfa_.IsDefault()) {
    _impl_.idfa_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.AccountLog.Idfa)
}

// string Imodel = 6;
inline void AccountLog::clear_imodel() {
  _impl_.imodel_.ClearToEmpty();
}
inline const std::string& AccountLog::imodel() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLog.Imodel)
  return _internal_imodel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountLog::set_imodel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.imodel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLog.Imodel)
}
inline std::string* AccountLog::mutable_imodel() {
  std::string* _s = _internal_mutable_imodel();
  // @@protoc_insertion_point(field_mutable:symphony.proto.AccountLog.Imodel)
  return _s;
}
inline const std::string& AccountLog::_internal_imodel() const {
  return _impl_.imodel_.Get();
}
inline void AccountLog::_internal_set_imodel(const std::string& value) {
  
  _impl_.imodel_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountLog::_internal_mutable_imodel() {
  
  return _impl_.imodel_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountLog::release_imodel() {
  // @@protoc_insertion_point(field_release:symphony.proto.AccountLog.Imodel)
  return _impl_.imodel_.Release();
}
inline void AccountLog::set_allocated_imodel(std::string* imodel) {
  if (imodel != nullptr) {
    
  } else {
    
  }
  _impl_.imodel_.SetAllocated(imodel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.imodel_.IsDefault()) {
    _impl_.imodel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.AccountLog.Imodel)
}

// string Imei = 7;
inline void AccountLog::clear_imei() {
  _impl_.imei_.ClearToEmpty();
}
inline const std::string& AccountLog::imei() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLog.Imei)
  return _internal_imei();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountLog::set_imei(ArgT0&& arg0, ArgT... args) {
 
 _impl_.imei_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLog.Imei)
}
inline std::string* AccountLog::mutable_imei() {
  std::string* _s = _internal_mutable_imei();
  // @@protoc_insertion_point(field_mutable:symphony.proto.AccountLog.Imei)
  return _s;
}
inline const std::string& AccountLog::_internal_imei() const {
  return _impl_.imei_.Get();
}
inline void AccountLog::_internal_set_imei(const std::string& value) {
  
  _impl_.imei_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountLog::_internal_mutable_imei() {
  
  return _impl_.imei_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountLog::release_imei() {
  // @@protoc_insertion_point(field_release:symphony.proto.AccountLog.Imei)
  return _impl_.imei_.Release();
}
inline void AccountLog::set_allocated_imei(std::string* imei) {
  if (imei != nullptr) {
    
  } else {
    
  }
  _impl_.imei_.SetAllocated(imei, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.imei_.IsDefault()) {
    _impl_.imei_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.AccountLog.Imei)
}

// int32 IpAddr = 8;
inline void AccountLog::clear_ipaddr() {
  _impl_.ipaddr_ = 0;
}
inline int32_t AccountLog::_internal_ipaddr() const {
  return _impl_.ipaddr_;
}
inline int32_t AccountLog::ipaddr() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLog.IpAddr)
  return _internal_ipaddr();
}
inline void AccountLog::_internal_set_ipaddr(int32_t value) {
  
  _impl_.ipaddr_ = value;
}
inline void AccountLog::set_ipaddr(int32_t value) {
  _internal_set_ipaddr(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLog.IpAddr)
}

// -------------------------------------------------------------------

// AccountRegReq

// string AccountName = 1;
inline void AccountRegReq::clear_accountname() {
  _impl_.accountname_.ClearToEmpty();
}
inline const std::string& AccountRegReq::accountname() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountRegReq.AccountName)
  return _internal_accountname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRegReq::set_accountname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accountname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.AccountRegReq.AccountName)
}
inline std::string* AccountRegReq::mutable_accountname() {
  std::string* _s = _internal_mutable_accountname();
  // @@protoc_insertion_point(field_mutable:symphony.proto.AccountRegReq.AccountName)
  return _s;
}
inline const std::string& AccountRegReq::_internal_accountname() const {
  return _impl_.accountname_.Get();
}
inline void AccountRegReq::_internal_set_accountname(const std::string& value) {
  
  _impl_.accountname_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountRegReq::_internal_mutable_accountname() {
  
  return _impl_.accountname_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountRegReq::release_accountname() {
  // @@protoc_insertion_point(field_release:symphony.proto.AccountRegReq.AccountName)
  return _impl_.accountname_.Release();
}
inline void AccountRegReq::set_allocated_accountname(std::string* accountname) {
  if (accountname != nullptr) {
    
  } else {
    
  }
  _impl_.accountname_.SetAllocated(accountname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accountname_.IsDefault()) {
    _impl_.accountname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.AccountRegReq.AccountName)
}

// string Password = 2;
inline void AccountRegReq::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& AccountRegReq::password() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountRegReq.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRegReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.AccountRegReq.Password)
}
inline std::string* AccountRegReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:symphony.proto.AccountRegReq.Password)
  return _s;
}
inline const std::string& AccountRegReq::_internal_password() const {
  return _impl_.password_.Get();
}
inline void AccountRegReq::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountRegReq::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountRegReq::release_password() {
  // @@protoc_insertion_point(field_release:symphony.proto.AccountRegReq.Password)
  return _impl_.password_.Release();
}
inline void AccountRegReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.AccountRegReq.Password)
}

// int32 Channel = 3;
inline void AccountRegReq::clear_channel() {
  _impl_.channel_ = 0;
}
inline int32_t AccountRegReq::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t AccountRegReq::channel() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountRegReq.Channel)
  return _internal_channel();
}
inline void AccountRegReq::_internal_set_channel(int32_t value) {
  
  _impl_.channel_ = value;
}
inline void AccountRegReq::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountRegReq.Channel)
}

// .symphony.proto.AccountLog RegLog = 4;
inline bool AccountRegReq::_internal_has_reglog() const {
  return this != internal_default_instance() && _impl_.reglog_ != nullptr;
}
inline bool AccountRegReq::has_reglog() const {
  return _internal_has_reglog();
}
inline void AccountRegReq::clear_reglog() {
  if (GetArenaForAllocation() == nullptr && _impl_.reglog_ != nullptr) {
    delete _impl_.reglog_;
  }
  _impl_.reglog_ = nullptr;
}
inline const ::symphony::proto::AccountLog& AccountRegReq::_internal_reglog() const {
  const ::symphony::proto::AccountLog* p = _impl_.reglog_;
  return p != nullptr ? *p : reinterpret_cast<const ::symphony::proto::AccountLog&>(
      ::symphony::proto::_AccountLog_default_instance_);
}
inline const ::symphony::proto::AccountLog& AccountRegReq::reglog() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountRegReq.RegLog)
  return _internal_reglog();
}
inline void AccountRegReq::unsafe_arena_set_allocated_reglog(
    ::symphony::proto::AccountLog* reglog) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reglog_);
  }
  _impl_.reglog_ = reglog;
  if (reglog) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:symphony.proto.AccountRegReq.RegLog)
}
inline ::symphony::proto::AccountLog* AccountRegReq::release_reglog() {
  
  ::symphony::proto::AccountLog* temp = _impl_.reglog_;
  _impl_.reglog_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::symphony::proto::AccountLog* AccountRegReq::unsafe_arena_release_reglog() {
  // @@protoc_insertion_point(field_release:symphony.proto.AccountRegReq.RegLog)
  
  ::symphony::proto::AccountLog* temp = _impl_.reglog_;
  _impl_.reglog_ = nullptr;
  return temp;
}
inline ::symphony::proto::AccountLog* AccountRegReq::_internal_mutable_reglog() {
  
  if (_impl_.reglog_ == nullptr) {
    auto* p = CreateMaybeMessage<::symphony::proto::AccountLog>(GetArenaForAllocation());
    _impl_.reglog_ = p;
  }
  return _impl_.reglog_;
}
inline ::symphony::proto::AccountLog* AccountRegReq::mutable_reglog() {
  ::symphony::proto::AccountLog* _msg = _internal_mutable_reglog();
  // @@protoc_insertion_point(field_mutable:symphony.proto.AccountRegReq.RegLog)
  return _msg;
}
inline void AccountRegReq::set_allocated_reglog(::symphony::proto::AccountLog* reglog) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reglog_;
  }
  if (reglog) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reglog);
    if (message_arena != submessage_arena) {
      reglog = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reglog, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.reglog_ = reglog;
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.AccountRegReq.RegLog)
}

// -------------------------------------------------------------------

// AccountRegAck

// uint32 RetCode = 1;
inline void AccountRegAck::clear_retcode() {
  _impl_.retcode_ = 0u;
}
inline uint32_t AccountRegAck::_internal_retcode() const {
  return _impl_.retcode_;
}
inline uint32_t AccountRegAck::retcode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountRegAck.RetCode)
  return _internal_retcode();
}
inline void AccountRegAck::_internal_set_retcode(uint32_t value) {
  
  _impl_.retcode_ = value;
}
inline void AccountRegAck::set_retcode(uint32_t value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountRegAck.RetCode)
}

// uint64 AccountID = 2;
inline void AccountRegAck::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
}
inline uint64_t AccountRegAck::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t AccountRegAck::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountRegAck.AccountID)
  return _internal_accountid();
}
inline void AccountRegAck::_internal_set_accountid(uint64_t value) {
  
  _impl_.accountid_ = value;
}
inline void AccountRegAck::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountRegAck.AccountID)
}

// -------------------------------------------------------------------

// AccountLoginReq

// string AccountName = 1;
inline void AccountLoginReq::clear_accountname() {
  _impl_.accountname_.ClearToEmpty();
}
inline const std::string& AccountLoginReq::accountname() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginReq.AccountName)
  return _internal_accountname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountLoginReq::set_accountname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accountname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLoginReq.AccountName)
}
inline std::string* AccountLoginReq::mutable_accountname() {
  std::string* _s = _internal_mutable_accountname();
  // @@protoc_insertion_point(field_mutable:symphony.proto.AccountLoginReq.AccountName)
  return _s;
}
inline const std::string& AccountLoginReq::_internal_accountname() const {
  return _impl_.accountname_.Get();
}
inline void AccountLoginReq::_internal_set_accountname(const std::string& value) {
  
  _impl_.accountname_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountLoginReq::_internal_mutable_accountname() {
  
  return _impl_.accountname_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountLoginReq::release_accountname() {
  // @@protoc_insertion_point(field_release:symphony.proto.AccountLoginReq.AccountName)
  return _impl_.accountname_.Release();
}
inline void AccountLoginReq::set_allocated_accountname(std::string* accountname) {
  if (accountname != nullptr) {
    
  } else {
    
  }
  _impl_.accountname_.SetAllocated(accountname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accountname_.IsDefault()) {
    _impl_.accountname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.AccountLoginReq.AccountName)
}

// string Password = 2;
inline void AccountLoginReq::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& AccountLoginReq::password() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginReq.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountLoginReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLoginReq.Password)
}
inline std::string* AccountLoginReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:symphony.proto.AccountLoginReq.Password)
  return _s;
}
inline const std::string& AccountLoginReq::_internal_password() const {
  return _impl_.password_.Get();
}
inline void AccountLoginReq::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountLoginReq::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountLoginReq::release_password() {
  // @@protoc_insertion_point(field_release:symphony.proto.AccountLoginReq.Password)
  return _impl_.password_.Release();
}
inline void AccountLoginReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.AccountLoginReq.Password)
}

// int32 Channel = 3;
inline void AccountLoginReq::clear_channel() {
  _impl_.channel_ = 0;
}
inline int32_t AccountLoginReq::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t AccountLoginReq::channel() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginReq.Channel)
  return _internal_channel();
}
inline void AccountLoginReq::_internal_set_channel(int32_t value) {
  
  _impl_.channel_ = value;
}
inline void AccountLoginReq::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLoginReq.Channel)
}

// bool FromChannel = 4;
inline void AccountLoginReq::clear_fromchannel() {
  _impl_.fromchannel_ = false;
}
inline bool AccountLoginReq::_internal_fromchannel() const {
  return _impl_.fromchannel_;
}
inline bool AccountLoginReq::fromchannel() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginReq.FromChannel)
  return _internal_fromchannel();
}
inline void AccountLoginReq::_internal_set_fromchannel(bool value) {
  
  _impl_.fromchannel_ = value;
}
inline void AccountLoginReq::set_fromchannel(bool value) {
  _internal_set_fromchannel(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLoginReq.FromChannel)
}

// bool Review = 5;
inline void AccountLoginReq::clear_review() {
  _impl_.review_ = false;
}
inline bool AccountLoginReq::_internal_review() const {
  return _impl_.review_;
}
inline bool AccountLoginReq::review() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginReq.Review)
  return _internal_review();
}
inline void AccountLoginReq::_internal_set_review(bool value) {
  
  _impl_.review_ = value;
}
inline void AccountLoginReq::set_review(bool value) {
  _internal_set_review(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLoginReq.Review)
}

// .symphony.proto.AccountLog LoginLog = 6;
inline bool AccountLoginReq::_internal_has_loginlog() const {
  return this != internal_default_instance() && _impl_.loginlog_ != nullptr;
}
inline bool AccountLoginReq::has_loginlog() const {
  return _internal_has_loginlog();
}
inline void AccountLoginReq::clear_loginlog() {
  if (GetArenaForAllocation() == nullptr && _impl_.loginlog_ != nullptr) {
    delete _impl_.loginlog_;
  }
  _impl_.loginlog_ = nullptr;
}
inline const ::symphony::proto::AccountLog& AccountLoginReq::_internal_loginlog() const {
  const ::symphony::proto::AccountLog* p = _impl_.loginlog_;
  return p != nullptr ? *p : reinterpret_cast<const ::symphony::proto::AccountLog&>(
      ::symphony::proto::_AccountLog_default_instance_);
}
inline const ::symphony::proto::AccountLog& AccountLoginReq::loginlog() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginReq.LoginLog)
  return _internal_loginlog();
}
inline void AccountLoginReq::unsafe_arena_set_allocated_loginlog(
    ::symphony::proto::AccountLog* loginlog) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loginlog_);
  }
  _impl_.loginlog_ = loginlog;
  if (loginlog) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:symphony.proto.AccountLoginReq.LoginLog)
}
inline ::symphony::proto::AccountLog* AccountLoginReq::release_loginlog() {
  
  ::symphony::proto::AccountLog* temp = _impl_.loginlog_;
  _impl_.loginlog_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::symphony::proto::AccountLog* AccountLoginReq::unsafe_arena_release_loginlog() {
  // @@protoc_insertion_point(field_release:symphony.proto.AccountLoginReq.LoginLog)
  
  ::symphony::proto::AccountLog* temp = _impl_.loginlog_;
  _impl_.loginlog_ = nullptr;
  return temp;
}
inline ::symphony::proto::AccountLog* AccountLoginReq::_internal_mutable_loginlog() {
  
  if (_impl_.loginlog_ == nullptr) {
    auto* p = CreateMaybeMessage<::symphony::proto::AccountLog>(GetArenaForAllocation());
    _impl_.loginlog_ = p;
  }
  return _impl_.loginlog_;
}
inline ::symphony::proto::AccountLog* AccountLoginReq::mutable_loginlog() {
  ::symphony::proto::AccountLog* _msg = _internal_mutable_loginlog();
  // @@protoc_insertion_point(field_mutable:symphony.proto.AccountLoginReq.LoginLog)
  return _msg;
}
inline void AccountLoginReq::set_allocated_loginlog(::symphony::proto::AccountLog* loginlog) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loginlog_;
  }
  if (loginlog) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loginlog);
    if (message_arena != submessage_arena) {
      loginlog = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loginlog, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.loginlog_ = loginlog;
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.AccountLoginReq.LoginLog)
}

// -------------------------------------------------------------------

// AccountLoginAck

// uint32 RetCode = 1;
inline void AccountLoginAck::clear_retcode() {
  _impl_.retcode_ = 0u;
}
inline uint32_t AccountLoginAck::_internal_retcode() const {
  return _impl_.retcode_;
}
inline uint32_t AccountLoginAck::retcode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginAck.RetCode)
  return _internal_retcode();
}
inline void AccountLoginAck::_internal_set_retcode(uint32_t value) {
  
  _impl_.retcode_ = value;
}
inline void AccountLoginAck::set_retcode(uint32_t value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLoginAck.RetCode)
}

// uint64 AccountID = 2;
inline void AccountLoginAck::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
}
inline uint64_t AccountLoginAck::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t AccountLoginAck::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginAck.AccountID)
  return _internal_accountid();
}
inline void AccountLoginAck::_internal_set_accountid(uint64_t value) {
  
  _impl_.accountid_ = value;
}
inline void AccountLoginAck::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLoginAck.AccountID)
}

// int32 LastSvrID = 3;
inline void AccountLoginAck::clear_lastsvrid() {
  _impl_.lastsvrid_ = 0;
}
inline int32_t AccountLoginAck::_internal_lastsvrid() const {
  return _impl_.lastsvrid_;
}
inline int32_t AccountLoginAck::lastsvrid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginAck.LastSvrID)
  return _internal_lastsvrid();
}
inline void AccountLoginAck::_internal_set_lastsvrid(int32_t value) {
  
  _impl_.lastsvrid_ = value;
}
inline void AccountLoginAck::set_lastsvrid(int32_t value) {
  _internal_set_lastsvrid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLoginAck.LastSvrID)
}

// string LastSvrName = 4;
inline void AccountLoginAck::clear_lastsvrname() {
  _impl_.lastsvrname_.ClearToEmpty();
}
inline const std::string& AccountLoginAck::lastsvrname() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginAck.LastSvrName)
  return _internal_lastsvrname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountLoginAck::set_lastsvrname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lastsvrname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLoginAck.LastSvrName)
}
inline std::string* AccountLoginAck::mutable_lastsvrname() {
  std::string* _s = _internal_mutable_lastsvrname();
  // @@protoc_insertion_point(field_mutable:symphony.proto.AccountLoginAck.LastSvrName)
  return _s;
}
inline const std::string& AccountLoginAck::_internal_lastsvrname() const {
  return _impl_.lastsvrname_.Get();
}
inline void AccountLoginAck::_internal_set_lastsvrname(const std::string& value) {
  
  _impl_.lastsvrname_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountLoginAck::_internal_mutable_lastsvrname() {
  
  return _impl_.lastsvrname_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountLoginAck::release_lastsvrname() {
  // @@protoc_insertion_point(field_release:symphony.proto.AccountLoginAck.LastSvrName)
  return _impl_.lastsvrname_.Release();
}
inline void AccountLoginAck::set_allocated_lastsvrname(std::string* lastsvrname) {
  if (lastsvrname != nullptr) {
    
  } else {
    
  }
  _impl_.lastsvrname_.SetAllocated(lastsvrname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lastsvrname_.IsDefault()) {
    _impl_.lastsvrname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.AccountLoginAck.LastSvrName)
}

// bool Review = 5;
inline void AccountLoginAck::clear_review() {
  _impl_.review_ = false;
}
inline bool AccountLoginAck::_internal_review() const {
  return _impl_.review_;
}
inline bool AccountLoginAck::review() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginAck.Review)
  return _internal_review();
}
inline void AccountLoginAck::_internal_set_review(bool value) {
  
  _impl_.review_ = value;
}
inline void AccountLoginAck::set_review(bool value) {
  _internal_set_review(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLoginAck.Review)
}

// int32 Channel = 6;
inline void AccountLoginAck::clear_channel() {
  _impl_.channel_ = 0;
}
inline int32_t AccountLoginAck::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t AccountLoginAck::channel() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginAck.Channel)
  return _internal_channel();
}
inline void AccountLoginAck::_internal_set_channel(int32_t value) {
  
  _impl_.channel_ = value;
}
inline void AccountLoginAck::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLoginAck.Channel)
}

// int32 IpAddr = 7;
inline void AccountLoginAck::clear_ipaddr() {
  _impl_.ipaddr_ = 0;
}
inline int32_t AccountLoginAck::_internal_ipaddr() const {
  return _impl_.ipaddr_;
}
inline int32_t AccountLoginAck::ipaddr() const {
  // @@protoc_insertion_point(field_get:symphony.proto.AccountLoginAck.IpAddr)
  return _internal_ipaddr();
}
inline void AccountLoginAck::_internal_set_ipaddr(int32_t value) {
  
  _impl_.ipaddr_ = value;
}
inline void AccountLoginAck::set_ipaddr(int32_t value) {
  _internal_set_ipaddr(value);
  // @@protoc_insertion_point(field_set:symphony.proto.AccountLoginAck.IpAddr)
}

// -------------------------------------------------------------------

// ClientServerListReq

// uint64 AccountID = 1;
inline void ClientServerListReq::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
}
inline uint64_t ClientServerListReq::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t ClientServerListReq::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.ClientServerListReq.AccountID)
  return _internal_accountid();
}
inline void ClientServerListReq::_internal_set_accountid(uint64_t value) {
  
  _impl_.accountid_ = value;
}
inline void ClientServerListReq::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.ClientServerListReq.AccountID)
}

// int32 Channel = 2;
inline void ClientServerListReq::clear_channel() {
  _impl_.channel_ = 0;
}
inline int32_t ClientServerListReq::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t ClientServerListReq::channel() const {
  // @@protoc_insertion_point(field_get:symphony.proto.ClientServerListReq.Channel)
  return _internal_channel();
}
inline void ClientServerListReq::_internal_set_channel(int32_t value) {
  
  _impl_.channel_ = value;
}
inline void ClientServerListReq::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:symphony.proto.ClientServerListReq.Channel)
}

// string Version = 3;
inline void ClientServerListReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ClientServerListReq::version() const {
  // @@protoc_insertion_point(field_get:symphony.proto.ClientServerListReq.Version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientServerListReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.ClientServerListReq.Version)
}
inline std::string* ClientServerListReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:symphony.proto.ClientServerListReq.Version)
  return _s;
}
inline const std::string& ClientServerListReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ClientServerListReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientServerListReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientServerListReq::release_version() {
  // @@protoc_insertion_point(field_release:symphony.proto.ClientServerListReq.Version)
  return _impl_.version_.Release();
}
inline void ClientServerListReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.ClientServerListReq.Version)
}

// bool Review = 4;
inline void ClientServerListReq::clear_review() {
  _impl_.review_ = false;
}
inline bool ClientServerListReq::_internal_review() const {
  return _impl_.review_;
}
inline bool ClientServerListReq::review() const {
  // @@protoc_insertion_point(field_get:symphony.proto.ClientServerListReq.Review)
  return _internal_review();
}
inline void ClientServerListReq::_internal_set_review(bool value) {
  
  _impl_.review_ = value;
}
inline void ClientServerListReq::set_review(bool value) {
  _internal_set_review(value);
  // @@protoc_insertion_point(field_set:symphony.proto.ClientServerListReq.Review)
}

// -------------------------------------------------------------------

// ClientServerNode

// int32 SvrID = 1;
inline void ClientServerNode::clear_svrid() {
  _impl_.svrid_ = 0;
}
inline int32_t ClientServerNode::_internal_svrid() const {
  return _impl_.svrid_;
}
inline int32_t ClientServerNode::svrid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.ClientServerNode.SvrID)
  return _internal_svrid();
}
inline void ClientServerNode::_internal_set_svrid(int32_t value) {
  
  _impl_.svrid_ = value;
}
inline void ClientServerNode::set_svrid(int32_t value) {
  _internal_set_svrid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.ClientServerNode.SvrID)
}

// string SvrName = 2;
inline void ClientServerNode::clear_svrname() {
  _impl_.svrname_.ClearToEmpty();
}
inline const std::string& ClientServerNode::svrname() const {
  // @@protoc_insertion_point(field_get:symphony.proto.ClientServerNode.SvrName)
  return _internal_svrname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientServerNode::set_svrname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.svrname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.ClientServerNode.SvrName)
}
inline std::string* ClientServerNode::mutable_svrname() {
  std::string* _s = _internal_mutable_svrname();
  // @@protoc_insertion_point(field_mutable:symphony.proto.ClientServerNode.SvrName)
  return _s;
}
inline const std::string& ClientServerNode::_internal_svrname() const {
  return _impl_.svrname_.Get();
}
inline void ClientServerNode::_internal_set_svrname(const std::string& value) {
  
  _impl_.svrname_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientServerNode::_internal_mutable_svrname() {
  
  return _impl_.svrname_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientServerNode::release_svrname() {
  // @@protoc_insertion_point(field_release:symphony.proto.ClientServerNode.SvrName)
  return _impl_.svrname_.Release();
}
inline void ClientServerNode::set_allocated_svrname(std::string* svrname) {
  if (svrname != nullptr) {
    
  } else {
    
  }
  _impl_.svrname_.SetAllocated(svrname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.svrname_.IsDefault()) {
    _impl_.svrname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.ClientServerNode.SvrName)
}

// int32 SvrFlag = 3;
inline void ClientServerNode::clear_svrflag() {
  _impl_.svrflag_ = 0;
}
inline int32_t ClientServerNode::_internal_svrflag() const {
  return _impl_.svrflag_;
}
inline int32_t ClientServerNode::svrflag() const {
  // @@protoc_insertion_point(field_get:symphony.proto.ClientServerNode.SvrFlag)
  return _internal_svrflag();
}
inline void ClientServerNode::_internal_set_svrflag(int32_t value) {
  
  _impl_.svrflag_ = value;
}
inline void ClientServerNode::set_svrflag(int32_t value) {
  _internal_set_svrflag(value);
  // @@protoc_insertion_point(field_set:symphony.proto.ClientServerNode.SvrFlag)
}

// int32 CornerMark = 4;
inline void ClientServerNode::clear_cornermark() {
  _impl_.cornermark_ = 0;
}
inline int32_t ClientServerNode::_internal_cornermark() const {
  return _impl_.cornermark_;
}
inline int32_t ClientServerNode::cornermark() const {
  // @@protoc_insertion_point(field_get:symphony.proto.ClientServerNode.CornerMark)
  return _internal_cornermark();
}
inline void ClientServerNode::_internal_set_cornermark(int32_t value) {
  
  _impl_.cornermark_ = value;
}
inline void ClientServerNode::set_cornermark(int32_t value) {
  _internal_set_cornermark(value);
  // @@protoc_insertion_point(field_set:symphony.proto.ClientServerNode.CornerMark)
}

// int64 SvrOpenTime = 5;
inline void ClientServerNode::clear_svropentime() {
  _impl_.svropentime_ = int64_t{0};
}
inline int64_t ClientServerNode::_internal_svropentime() const {
  return _impl_.svropentime_;
}
inline int64_t ClientServerNode::svropentime() const {
  // @@protoc_insertion_point(field_get:symphony.proto.ClientServerNode.SvrOpenTime)
  return _internal_svropentime();
}
inline void ClientServerNode::_internal_set_svropentime(int64_t value) {
  
  _impl_.svropentime_ = value;
}
inline void ClientServerNode::set_svropentime(int64_t value) {
  _internal_set_svropentime(value);
  // @@protoc_insertion_point(field_set:symphony.proto.ClientServerNode.SvrOpenTime)
}

// int32 SvrStatus = 6;
inline void ClientServerNode::clear_svrstatus() {
  _impl_.svrstatus_ = 0;
}
inline int32_t ClientServerNode::_internal_svrstatus() const {
  return _impl_.svrstatus_;
}
inline int32_t ClientServerNode::svrstatus() const {
  // @@protoc_insertion_point(field_get:symphony.proto.ClientServerNode.SvrStatus)
  return _internal_svrstatus();
}
inline void ClientServerNode::_internal_set_svrstatus(int32_t value) {
  
  _impl_.svrstatus_ = value;
}
inline void ClientServerNode::set_svrstatus(int32_t value) {
  _internal_set_svrstatus(value);
  // @@protoc_insertion_point(field_set:symphony.proto.ClientServerNode.SvrStatus)
}

// -------------------------------------------------------------------

// ClientServerListAck

// uint32 RetCode = 1;
inline void ClientServerListAck::clear_retcode() {
  _impl_.retcode_ = 0u;
}
inline uint32_t ClientServerListAck::_internal_retcode() const {
  return _impl_.retcode_;
}
inline uint32_t ClientServerListAck::retcode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.ClientServerListAck.RetCode)
  return _internal_retcode();
}
inline void ClientServerListAck::_internal_set_retcode(uint32_t value) {
  
  _impl_.retcode_ = value;
}
inline void ClientServerListAck::set_retcode(uint32_t value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.ClientServerListAck.RetCode)
}

// repeated .symphony.proto.ClientServerNode SvrNode = 2;
inline int ClientServerListAck::_internal_svrnode_size() const {
  return _impl_.svrnode_.size();
}
inline int ClientServerListAck::svrnode_size() const {
  return _internal_svrnode_size();
}
inline void ClientServerListAck::clear_svrnode() {
  _impl_.svrnode_.Clear();
}
inline ::symphony::proto::ClientServerNode* ClientServerListAck::mutable_svrnode(int index) {
  // @@protoc_insertion_point(field_mutable:symphony.proto.ClientServerListAck.SvrNode)
  return _impl_.svrnode_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::symphony::proto::ClientServerNode >*
ClientServerListAck::mutable_svrnode() {
  // @@protoc_insertion_point(field_mutable_list:symphony.proto.ClientServerListAck.SvrNode)
  return &_impl_.svrnode_;
}
inline const ::symphony::proto::ClientServerNode& ClientServerListAck::_internal_svrnode(int index) const {
  return _impl_.svrnode_.Get(index);
}
inline const ::symphony::proto::ClientServerNode& ClientServerListAck::svrnode(int index) const {
  // @@protoc_insertion_point(field_get:symphony.proto.ClientServerListAck.SvrNode)
  return _internal_svrnode(index);
}
inline ::symphony::proto::ClientServerNode* ClientServerListAck::_internal_add_svrnode() {
  return _impl_.svrnode_.Add();
}
inline ::symphony::proto::ClientServerNode* ClientServerListAck::add_svrnode() {
  ::symphony::proto::ClientServerNode* _add = _internal_add_svrnode();
  // @@protoc_insertion_point(field_add:symphony.proto.ClientServerListAck.SvrNode)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::symphony::proto::ClientServerNode >&
ClientServerListAck::svrnode() const {
  // @@protoc_insertion_point(field_list:symphony.proto.ClientServerListAck.SvrNode)
  return _impl_.svrnode_;
}

// -------------------------------------------------------------------

// SelectServerReq

// uint64 AccountID = 1;
inline void SelectServerReq::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
}
inline uint64_t SelectServerReq::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t SelectServerReq::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SelectServerReq.AccountID)
  return _internal_accountid();
}
inline void SelectServerReq::_internal_set_accountid(uint64_t value) {
  
  _impl_.accountid_ = value;
}
inline void SelectServerReq::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SelectServerReq.AccountID)
}

// int32 ServerID = 2;
inline void SelectServerReq::clear_serverid() {
  _impl_.serverid_ = 0;
}
inline int32_t SelectServerReq::_internal_serverid() const {
  return _impl_.serverid_;
}
inline int32_t SelectServerReq::serverid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SelectServerReq.ServerID)
  return _internal_serverid();
}
inline void SelectServerReq::_internal_set_serverid(int32_t value) {
  
  _impl_.serverid_ = value;
}
inline void SelectServerReq::set_serverid(int32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SelectServerReq.ServerID)
}

// bool CheckRole = 3;
inline void SelectServerReq::clear_checkrole() {
  _impl_.checkrole_ = false;
}
inline bool SelectServerReq::_internal_checkrole() const {
  return _impl_.checkrole_;
}
inline bool SelectServerReq::checkrole() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SelectServerReq.CheckRole)
  return _internal_checkrole();
}
inline void SelectServerReq::_internal_set_checkrole(bool value) {
  
  _impl_.checkrole_ = value;
}
inline void SelectServerReq::set_checkrole(bool value) {
  _internal_set_checkrole(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SelectServerReq.CheckRole)
}

// -------------------------------------------------------------------

// SelectServerAck

// uint32 RetCode = 1;
inline void SelectServerAck::clear_retcode() {
  _impl_.retcode_ = 0u;
}
inline uint32_t SelectServerAck::_internal_retcode() const {
  return _impl_.retcode_;
}
inline uint32_t SelectServerAck::retcode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SelectServerAck.RetCode)
  return _internal_retcode();
}
inline void SelectServerAck::_internal_set_retcode(uint32_t value) {
  
  _impl_.retcode_ = value;
}
inline void SelectServerAck::set_retcode(uint32_t value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SelectServerAck.RetCode)
}

// uint64 AccountID = 2;
inline void SelectServerAck::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
}
inline uint64_t SelectServerAck::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t SelectServerAck::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SelectServerAck.AccountID)
  return _internal_accountid();
}
inline void SelectServerAck::_internal_set_accountid(uint64_t value) {
  
  _impl_.accountid_ = value;
}
inline void SelectServerAck::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SelectServerAck.AccountID)
}

// int32 ServerID = 3;
inline void SelectServerAck::clear_serverid() {
  _impl_.serverid_ = 0;
}
inline int32_t SelectServerAck::_internal_serverid() const {
  return _impl_.serverid_;
}
inline int32_t SelectServerAck::serverid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SelectServerAck.ServerID)
  return _internal_serverid();
}
inline void SelectServerAck::_internal_set_serverid(int32_t value) {
  
  _impl_.serverid_ = value;
}
inline void SelectServerAck::set_serverid(int32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SelectServerAck.ServerID)
}

// string ServerAddr = 4;
inline void SelectServerAck::clear_serveraddr() {
  _impl_.serveraddr_.ClearToEmpty();
}
inline const std::string& SelectServerAck::serveraddr() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SelectServerAck.ServerAddr)
  return _internal_serveraddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectServerAck::set_serveraddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serveraddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.SelectServerAck.ServerAddr)
}
inline std::string* SelectServerAck::mutable_serveraddr() {
  std::string* _s = _internal_mutable_serveraddr();
  // @@protoc_insertion_point(field_mutable:symphony.proto.SelectServerAck.ServerAddr)
  return _s;
}
inline const std::string& SelectServerAck::_internal_serveraddr() const {
  return _impl_.serveraddr_.Get();
}
inline void SelectServerAck::_internal_set_serveraddr(const std::string& value) {
  
  _impl_.serveraddr_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectServerAck::_internal_mutable_serveraddr() {
  
  return _impl_.serveraddr_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectServerAck::release_serveraddr() {
  // @@protoc_insertion_point(field_release:symphony.proto.SelectServerAck.ServerAddr)
  return _impl_.serveraddr_.Release();
}
inline void SelectServerAck::set_allocated_serveraddr(std::string* serveraddr) {
  if (serveraddr != nullptr) {
    
  } else {
    
  }
  _impl_.serveraddr_.SetAllocated(serveraddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serveraddr_.IsDefault()) {
    _impl_.serveraddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.SelectServerAck.ServerAddr)
}

// int32 ServerPort = 5;
inline void SelectServerAck::clear_serverport() {
  _impl_.serverport_ = 0;
}
inline int32_t SelectServerAck::_internal_serverport() const {
  return _impl_.serverport_;
}
inline int32_t SelectServerAck::serverport() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SelectServerAck.ServerPort)
  return _internal_serverport();
}
inline void SelectServerAck::_internal_set_serverport(int32_t value) {
  
  _impl_.serverport_ = value;
}
inline void SelectServerAck::set_serverport(int32_t value) {
  _internal_set_serverport(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SelectServerAck.ServerPort)
}

// int32 LoginCode = 6;
inline void SelectServerAck::clear_logincode() {
  _impl_.logincode_ = 0;
}
inline int32_t SelectServerAck::_internal_logincode() const {
  return _impl_.logincode_;
}
inline int32_t SelectServerAck::logincode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SelectServerAck.LoginCode)
  return _internal_logincode();
}
inline void SelectServerAck::_internal_set_logincode(int32_t value) {
  
  _impl_.logincode_ = value;
}
inline void SelectServerAck::set_logincode(int32_t value) {
  _internal_set_logincode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SelectServerAck.LoginCode)
}

// -------------------------------------------------------------------

// SealAccountReq

// string AccountName = 1;
inline void SealAccountReq::clear_accountname() {
  _impl_.accountname_.ClearToEmpty();
}
inline const std::string& SealAccountReq::accountname() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SealAccountReq.AccountName)
  return _internal_accountname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SealAccountReq::set_accountname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accountname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.SealAccountReq.AccountName)
}
inline std::string* SealAccountReq::mutable_accountname() {
  std::string* _s = _internal_mutable_accountname();
  // @@protoc_insertion_point(field_mutable:symphony.proto.SealAccountReq.AccountName)
  return _s;
}
inline const std::string& SealAccountReq::_internal_accountname() const {
  return _impl_.accountname_.Get();
}
inline void SealAccountReq::_internal_set_accountname(const std::string& value) {
  
  _impl_.accountname_.Set(value, GetArenaForAllocation());
}
inline std::string* SealAccountReq::_internal_mutable_accountname() {
  
  return _impl_.accountname_.Mutable(GetArenaForAllocation());
}
inline std::string* SealAccountReq::release_accountname() {
  // @@protoc_insertion_point(field_release:symphony.proto.SealAccountReq.AccountName)
  return _impl_.accountname_.Release();
}
inline void SealAccountReq::set_allocated_accountname(std::string* accountname) {
  if (accountname != nullptr) {
    
  } else {
    
  }
  _impl_.accountname_.SetAllocated(accountname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accountname_.IsDefault()) {
    _impl_.accountname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.SealAccountReq.AccountName)
}

// uint64 AccountID = 2;
inline void SealAccountReq::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
}
inline uint64_t SealAccountReq::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t SealAccountReq::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SealAccountReq.AccountID)
  return _internal_accountid();
}
inline void SealAccountReq::_internal_set_accountid(uint64_t value) {
  
  _impl_.accountid_ = value;
}
inline void SealAccountReq::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SealAccountReq.AccountID)
}

// int32 Channel = 3;
inline void SealAccountReq::clear_channel() {
  _impl_.channel_ = 0;
}
inline int32_t SealAccountReq::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t SealAccountReq::channel() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SealAccountReq.Channel)
  return _internal_channel();
}
inline void SealAccountReq::_internal_set_channel(int32_t value) {
  
  _impl_.channel_ = value;
}
inline void SealAccountReq::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SealAccountReq.Channel)
}

// int32 SealTime = 4;
inline void SealAccountReq::clear_sealtime() {
  _impl_.sealtime_ = 0;
}
inline int32_t SealAccountReq::_internal_sealtime() const {
  return _impl_.sealtime_;
}
inline int32_t SealAccountReq::sealtime() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SealAccountReq.SealTime)
  return _internal_sealtime();
}
inline void SealAccountReq::_internal_set_sealtime(int32_t value) {
  
  _impl_.sealtime_ = value;
}
inline void SealAccountReq::set_sealtime(int32_t value) {
  _internal_set_sealtime(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SealAccountReq.SealTime)
}

// bool Seal = 5;
inline void SealAccountReq::clear_seal() {
  _impl_.seal_ = false;
}
inline bool SealAccountReq::_internal_seal() const {
  return _impl_.seal_;
}
inline bool SealAccountReq::seal() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SealAccountReq.Seal)
  return _internal_seal();
}
inline void SealAccountReq::_internal_set_seal(bool value) {
  
  _impl_.seal_ = value;
}
inline void SealAccountReq::set_seal(bool value) {
  _internal_set_seal(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SealAccountReq.Seal)
}

// -------------------------------------------------------------------

// SealAccountAck

// uint32 RetCode = 1;
inline void SealAccountAck::clear_retcode() {
  _impl_.retcode_ = 0u;
}
inline uint32_t SealAccountAck::_internal_retcode() const {
  return _impl_.retcode_;
}
inline uint32_t SealAccountAck::retcode() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SealAccountAck.RetCode)
  return _internal_retcode();
}
inline void SealAccountAck::_internal_set_retcode(uint32_t value) {
  
  _impl_.retcode_ = value;
}
inline void SealAccountAck::set_retcode(uint32_t value) {
  _internal_set_retcode(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SealAccountAck.RetCode)
}

// string AccountName = 2;
inline void SealAccountAck::clear_accountname() {
  _impl_.accountname_.ClearToEmpty();
}
inline const std::string& SealAccountAck::accountname() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SealAccountAck.AccountName)
  return _internal_accountname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SealAccountAck::set_accountname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accountname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:symphony.proto.SealAccountAck.AccountName)
}
inline std::string* SealAccountAck::mutable_accountname() {
  std::string* _s = _internal_mutable_accountname();
  // @@protoc_insertion_point(field_mutable:symphony.proto.SealAccountAck.AccountName)
  return _s;
}
inline const std::string& SealAccountAck::_internal_accountname() const {
  return _impl_.accountname_.Get();
}
inline void SealAccountAck::_internal_set_accountname(const std::string& value) {
  
  _impl_.accountname_.Set(value, GetArenaForAllocation());
}
inline std::string* SealAccountAck::_internal_mutable_accountname() {
  
  return _impl_.accountname_.Mutable(GetArenaForAllocation());
}
inline std::string* SealAccountAck::release_accountname() {
  // @@protoc_insertion_point(field_release:symphony.proto.SealAccountAck.AccountName)
  return _impl_.accountname_.Release();
}
inline void SealAccountAck::set_allocated_accountname(std::string* accountname) {
  if (accountname != nullptr) {
    
  } else {
    
  }
  _impl_.accountname_.SetAllocated(accountname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accountname_.IsDefault()) {
    _impl_.accountname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:symphony.proto.SealAccountAck.AccountName)
}

// uint64 AccountID = 3;
inline void SealAccountAck::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
}
inline uint64_t SealAccountAck::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t SealAccountAck::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SealAccountAck.AccountID)
  return _internal_accountid();
}
inline void SealAccountAck::_internal_set_accountid(uint64_t value) {
  
  _impl_.accountid_ = value;
}
inline void SealAccountAck::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SealAccountAck.AccountID)
}

// int32 ServerID = 4;
inline void SealAccountAck::clear_serverid() {
  _impl_.serverid_ = 0;
}
inline int32_t SealAccountAck::_internal_serverid() const {
  return _impl_.serverid_;
}
inline int32_t SealAccountAck::serverid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SealAccountAck.ServerID)
  return _internal_serverid();
}
inline void SealAccountAck::_internal_set_serverid(int32_t value) {
  
  _impl_.serverid_ = value;
}
inline void SealAccountAck::set_serverid(int32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SealAccountAck.ServerID)
}

// -------------------------------------------------------------------

// SealAccountNtf

// uint64 AccountID = 1;
inline void SealAccountNtf::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
}
inline uint64_t SealAccountNtf::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t SealAccountNtf::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SealAccountNtf.AccountID)
  return _internal_accountid();
}
inline void SealAccountNtf::_internal_set_accountid(uint64_t value) {
  
  _impl_.accountid_ = value;
}
inline void SealAccountNtf::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SealAccountNtf.AccountID)
}

// -------------------------------------------------------------------

// SetLastServerNty

// uint64 AccountID = 1;
inline void SetLastServerNty::clear_accountid() {
  _impl_.accountid_ = uint64_t{0u};
}
inline uint64_t SetLastServerNty::_internal_accountid() const {
  return _impl_.accountid_;
}
inline uint64_t SetLastServerNty::accountid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SetLastServerNty.AccountID)
  return _internal_accountid();
}
inline void SetLastServerNty::_internal_set_accountid(uint64_t value) {
  
  _impl_.accountid_ = value;
}
inline void SetLastServerNty::set_accountid(uint64_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SetLastServerNty.AccountID)
}

// int32 ServerID = 2;
inline void SetLastServerNty::clear_serverid() {
  _impl_.serverid_ = 0;
}
inline int32_t SetLastServerNty::_internal_serverid() const {
  return _impl_.serverid_;
}
inline int32_t SetLastServerNty::serverid() const {
  // @@protoc_insertion_point(field_get:symphony.proto.SetLastServerNty.ServerID)
  return _internal_serverid();
}
inline void SetLastServerNty::_internal_set_serverid(int32_t value) {
  
  _impl_.serverid_ = value;
}
inline void SetLastServerNty::set_serverid(int32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:symphony.proto.SetLastServerNty.ServerID)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace symphony

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_symphony_2fproto_2fmsg_5faccount_2eproto
